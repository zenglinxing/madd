/* coding: utf-8 */
/*
This code is generated by Deepseek
*/
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <stdbool.h>
#include <string.h>
#include <time.h>
#include <math.h>

// 包含您的希尔排序声明
#include "sort.h"

// ==================== 测试工具函数 ====================

// 比较两个数组是否相同
static bool arrays_equal(void* a, void* b, size_t n, size_t size) {
    return memcmp(a, b, n * size) == 0;
}

// 打印数组
static void print_array(void* arr, size_t n, size_t size, void(*print_func)(void*)) {
    printf("[");
    for (size_t i = 0; i < n; i++) {
        print_func((char*)arr + i * size);
        if (i < n - 1) printf(", ");
    }
    printf("]\n");
}

// 随机数生成器初始化
static void init_random() {
    srand((unsigned int)time(NULL));
}

// 生成随机整数数组
static void generate_random_int_array(int* arr, size_t n, int min, int max) {
    for (size_t i = 0; i < n; i++) {
        arr[i] = rand() % (max - min + 1) + min;
    }
}

// ==================== 测试用例 ====================

// 整数比较函数
static bool int_compare(void* a, void* b, void* other) {
    (void)other;
    return *(int*)a < *(int*)b;
}

// 结构体测试
typedef struct {
    int id;
    float value;
} TestStruct;

// 结构体比较函数
static bool struct_compare(void* a, void* b, void* other) {
    TestStruct* sa = (TestStruct*)a;
    TestStruct* sb = (TestStruct*)b;
    
    // 先按value排序，value相同按id排序
    if (fabsf(sa->value - sb->value) < 1e-6f) {
        return sa->id < sb->id;
    }
    return sa->value < sb->value;
}

// 整数打印函数
static void print_int(void* p) {
    printf("%d", *(int*)p);
}

// 结构体打印函数
static void print_struct(void* p) {
    TestStruct* s = (TestStruct*)p;
    printf("(%d, %.2f)", s->id, s->value);
}

// ==================== 测试套件 ====================

static int test_count = 0;
static int pass_count = 0;

// 测试宏 - 在Release模式下也能正常运行
#define TEST_CASE(name, block) \
static void test_##name() { \
    int _pass = 1; \
    printf("Test %d: %s... ", ++test_count, #name); \
    do { block } while(0); \
    if (_pass) { \
        printf("PASS\n"); \
        pass_count++; \
    } else { \
        printf("FAIL\n"); \
    } \
}

// 测试空数组
TEST_CASE(empty_array, {
    int arr[1] = {0}; // 非空但忽略
    Sort_Shell(0, sizeof(int), arr, int_compare, NULL);
    _pass = 1; // 只要不崩溃就通过
})

// 测试单元素数组
TEST_CASE(single_element, {
    int arr[1] = {42};
    int expected[1] = {42};
    
    Sort_Shell(1, sizeof(int), arr, int_compare, NULL);
    
    _pass = arrays_equal(arr, expected, 1, sizeof(int));
    if (!_pass) {
        printf("\n  Expected: [42]\n  Got: ");
        print_array(arr, 1, sizeof(int), print_int);
    }
})

// 测试已排序数组
TEST_CASE(already_sorted, {
    int arr[5] = {1, 2, 3, 4, 5};
    int expected[5] = {1, 2, 3, 4, 5};
    
    Sort_Shell(5, sizeof(int), arr, int_compare, NULL);
    
    _pass = arrays_equal(arr, expected, 5, sizeof(int));
    if (!_pass) {
        printf("\n  Expected: [1, 2, 3, 4, 5]\n  Got: ");
        print_array(arr, 5, sizeof(int), print_int);
    }
})

// 测试逆序数组
TEST_CASE(reverse_order, {
    int arr[5] = {5, 4, 3, 2, 1};
    int expected[5] = {1, 2, 3, 4, 5};
    
    Sort_Shell(5, sizeof(int), arr, int_compare, NULL);
    
    _pass = arrays_equal(arr, expected, 5, sizeof(int));
    if (!_pass) {
        printf("\n  Expected: [1, 2, 3, 4, 5]\n  Got: ");
        print_array(arr, 5, sizeof(int), print_int);
    }
})

// 测试全相同元素
TEST_CASE(all_same, {
    int arr[5] = {7, 7, 7, 7, 7};
    int expected[5] = {7, 7, 7, 7, 7};
    
    Sort_Shell(5, sizeof(int), arr, int_compare, NULL);
    
    _pass = arrays_equal(arr, expected, 5, sizeof(int));
    if (!_pass) {
        printf("\n  Expected: [7,7,7,7,7]\n  Got: ");
        print_array(arr, 5, sizeof(int), print_int);
    }
})

// 测试小随机数组
TEST_CASE(small_random, {
    int arr[10] = {3, 1, 4, 1, 5, 9, 2, 6, 5, 3};
    int expected[10] = {1, 1, 2, 3, 3, 4, 5, 5, 6, 9};
    
    Sort_Shell(10, sizeof(int), arr, int_compare, NULL);
    
    _pass = arrays_equal(arr, expected, 10, sizeof(int));
    if (!_pass) {
        printf("\n  Expected: [1,1,2,3,3,4,5,5,6,9]\n  Got: ");
        print_array(arr, 10, sizeof(int), print_int);
    }
})

// 测试大随机数组 (1000元素)
TEST_CASE(large_random, {
    const size_t n = 1000;
    int* arr = malloc(n * sizeof(int));
    int* sorted = malloc(n * sizeof(int));
    
    generate_random_int_array(arr, n, 0, 10000);
    memcpy(sorted, arr, n * sizeof(int));
    qsort(sorted, n, sizeof(int), (int(*)(const void*,const void*))int_compare);
    
    Sort_Shell(n, sizeof(int), arr, int_compare, NULL);
    
    _pass = arrays_equal(arr, sorted, n, sizeof(int));
    
    if (!_pass) {
        // 只打印前10个元素
        printf("\n  Expected: ");
        print_array(sorted, n > 10 ? 10 : n, sizeof(int), print_int);
        printf("  Got:      ");
        print_array(arr, n > 10 ? 10 : n, sizeof(int), print_int);
    }
    
    free(arr);
    free(sorted);
})

// 测试结构体数组
TEST_CASE(struct_array, {
    TestStruct arr[5] = {
        {1, 3.2f},
        {2, 1.5f},
        {3, 1.5f},
        {4, 2.8f},
        {5, 2.8f}
    };
    
    TestStruct expected[5] = {
        {2, 1.5f}, // id 2 < id 3
        {3, 1.5f},
        {4, 2.8f}, // id 4 < id 5
        {5, 2.8f},
        {1, 3.2f}
    };
    
    Sort_Shell(5, sizeof(TestStruct), arr, struct_compare, NULL);
    
    _pass = arrays_equal(arr, expected, 5, sizeof(TestStruct));
    if (!_pass) {
        printf("\n  Expected: ");
        print_array(expected, 5, sizeof(TestStruct), print_struct);
        printf("  Got:      ");
        print_array(arr, 5, sizeof(TestStruct), print_struct);
    }
})

// 测试超大元素大小
TEST_CASE(large_element_size, {
    typedef struct {
        int data[300]; // 1200字节 > 1024
        int key;
    } LargeStruct;
    
    const int n = 5;
    LargeStruct* arr = calloc(n, sizeof(LargeStruct));
    
    // 初始化
    for (int i = 0; i < n; i++) {
        arr[i].key = n - i - 1;
        arr[i].data[0] = i * 100;
    }
    
    // 比较函数
    bool compare(void* a, void* b, void* other) {
        (void)other;
        return ((LargeStruct*)a)->key < ((LargeStruct*)b)->key;
    }
    
    Sort_Shell(n, sizeof(LargeStruct), arr, compare, NULL);
    
    // 验证排序正确
    _pass = 1;
    for (int i = 0; i < n; i++) {
        if (arr[i].key != i) {
            _pass = 0;
            break;
        }
    }
    
    if (!_pass) {
        printf("\n  Expected keys: [0,1,2,3,4]\n  Got: ");
        for (int i = 0; i < n; i++) {
            printf("%d ", arr[i].key);
        }
    }
    
    free(arr);
})

// 测试边界情况 (2^20 元素)
TEST_CASE(large_array_boundary, {
    const size_t n = 1 << 20; // 1,048,576 元素
    int* arr = malloc(n * sizeof(int));
    int* sorted = malloc(n * sizeof(int));
    
    if (!arr || !sorted) {
        printf("SKIP (内存不足)\n");
        _pass = 1; // 不算失败
        goto cleanup;
    }
    
    generate_random_int_array(arr, n, 0, INT_MAX);
    memcpy(sorted, arr, n * sizeof(int));
    qsort(sorted, n, sizeof(int), (int(*)(const void*,const void*))int_compare);
    
    clock_t start = clock();
    Sort_Shell(n, sizeof(int), arr, int_compare, NULL);
    clock_t end = clock();
    
    printf("(耗时: %.2f秒) ", (double)(end - start) / CLOCKS_PER_SEC);
    
    _pass = arrays_equal(arr, sorted, n, sizeof(int));
    
    if (!_pass) {
        // 随机检查10个位置
        int errors = 0;
        for (int i = 0; i < 10; i++) {
            size_t idx = rand() % n;
            if (arr[idx] != sorted[idx]) errors++;
        }
        printf("\n  %d/10随机位置错误", errors);
    }
    
cleanup:
    free(arr);
    free(sorted);
})

// ==================== 主测试函数 ====================

int main() {
    init_random();
    
    printf("===== 开始希尔排序测试 =====\n");
    
    // 初始化 Sedgewick 序列（测试需要）
    // 实际使用中应由 C++ 全局构造函数完成
    printf("初始化 Sedgewick 序列...\n");
    {
        uint64_t s1[30], s2[30];
        uint64_t i4 = 1, i2 = 1;
        
        // 生成 s1 序列
        for (int i = 0; i < 30; i++) {
            if (i > 0) {
                i4 *= 4;
                i2 *= 2;
            }
            s1[i] = 9 * (i4 - i2) + 1;
        }
        
        // 生成 s2 序列
        i4 = 16; // 4^2
        i2 = 4;  // 2^2
        for (int i = 2; i < 32; i++) {
            s2[i-2] = i4 - 3*i2 + 1;
            i4 *= 4;
            i2 *= 2;
        }
        
        // 合并序列
        int i = 0, j = 0, k = 0;
        while (i < 30 && j < 30) {
            if (s1[i] < s2[j]) {
                madd_shell_sort_sedgewick[k++] = s1[i++];
            } else {
                madd_shell_sort_sedgewick[k++] = s2[j++];
            }
        }
        while (i < 30) madd_shell_sort_sedgewick[k++] = s1[i++];
        while (j < 30) madd_shell_sort_sedgewick[k++] = s2[j++];
    }
    
    // 运行所有测试
    test_empty_array();
    test_single_element();
    test_already_sorted();
    test_reverse_order();
    test_all_same();
    test_small_random();
    test_large_random();
    test_struct_array();
    test_large_element_size();
    test_large_array_boundary();
    
    // 打印结果
    printf("\n===== 测试结果 =====\n");
    printf("通过: %d/%d\n", pass_count, test_count);
    printf("状态: %s\n", pass_count == test_count ? "所有测试通过" : "存在失败测试");
    
    return pass_count == test_count ? 0 : 1;
}