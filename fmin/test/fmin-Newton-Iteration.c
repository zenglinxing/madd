/* coding: utf-8 */
/*
 * Test code for Newton Iteration method
This code is generated by Deepseek-R1
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include"madd.h"

// Test function 1: Quadratic function f(x) = (x-2)^2, minimum at x=2
double quadratic_1d(double* params, void* other_param) {
    double x = params[0];
    return (x - 2.0) * (x - 2.0);
}

// Test function 2: Rosenbrock function f(x,y) = (1-x)^2 + 100*(y-x^2)^2, minimum at (1,1)
double rosenbrock_2d(double* params, void* other_param) {
    double x = params[0];
    double y = params[1];
    return (1.0 - x) * (1.0 - x) + 100.0 * (y - x * x) * (y - x * x);
}

// Test function 3: Simple 2D quadratic, minimum at (3, -2)
double quadratic_2d(double* params, void* other_param) {
    double x = params[0];
    double y = params[1];
    return (x - 3.0) * (x - 3.0) + 2.0 * (y + 2.0) * (y + 2.0) + x * y;
}

// Utility function to compare doubles with tolerance
int double_equal(double a, double b, double tolerance) {
    return fabs(a - b) < tolerance;
}

// Test case structure
typedef struct {
    char* name;
    int (*test_func)(void);
} test_case_t;

// Global variable to track test failures
int global_test_failures = 0;

// Test 1: 1D quadratic function minimization
int test_quadratic_1d() {
    printf("Running test_quadratic_1d...\n");
    
    double params[1] = {0.0};  // Initial guess at x=0
    double steps[1] = {0.001}; // Step size for numerical differentiation
    uint64_t n_steps = 10;
    
    bool success = Fmin_Newton_Iteration(1, params, quadratic_1d, NULL, steps, 0.0, n_steps);
    
    if (!success) {
        printf("  FAIL: Function returned false\n");
        return 1;
    }
    
    double expected = 2.0;
    double tolerance = 1e-6;
    
    if (!double_equal(params[0], expected, tolerance)) {
        printf("  FAIL: Expected %.6f, got %.6f\n", expected, params[0]);
        return 1;
    }
    
    printf("  PASS: Found minimum at x = %.6f\n", params[0]);
    return 0;
}

// Test 2: 2D Rosenbrock function minimization
int test_rosenbrock_2d() {
    printf("Running test_rosenbrock_2d...\n");
    
    double params[2] = {0.0, 0.0};  // Initial guess
    double steps[2] = {1e-7, 1e-7};
    uint64_t n_steps = 800;
    
    bool success = Fmin_Newton_Iteration(2, params, rosenbrock_2d, NULL, steps, 1e-9, n_steps);
    
    if (!success) {
        printf("  FAIL: Function returned false\n");
        return 1;
    }
    
    double expected_x = 1.0;
    double expected_y = 1.0;
    double tolerance = 1e-4;
    
    if (!double_equal(params[0], expected_x, tolerance) || 
        !double_equal(params[1], expected_y, tolerance)) {
        printf("  FAIL: Expected (%.6f, %.6f), got (%.6f, %.6f)\n", 
               expected_x, expected_y, params[0], params[1]);
        return 1;
    }
    
    printf("  PASS: Found minimum at (%.6f, %.6f)\n", params[0], params[1]);
    return 0;
}

// Test 3: Simple 2D quadratic with regularization
int test_quadratic_2d_with_regularization() {
    printf("Running test_quadratic_2d_with_regularization...\n");
    
    double params[2] = {0.0, 0.0};
    double steps[2] = {1e-7, 1e-7};
    uint64_t n_steps = 800;
    double norm_term = 1e-7;  // Regularization term
    
    bool success = Fmin_Newton_Iteration(2, params, quadratic_2d, NULL, steps, norm_term, n_steps);
    
    if (!success) {
        printf("  FAIL: Function returned false\n");
        return 1;
    }
    
    // With regularization, we might not get exact minimum, but should be close
    double expected_x = 4.57145055; // 3.0;
    double expected_y = -3.14287153; // -2.0; Deepseek gave the wrong expected values
    double tolerance = 1e-3;
    
    if (!double_equal(params[0], expected_x, tolerance) || 
        !double_equal(params[1], expected_y, tolerance)) {
        printf("  FAIL: Expected (%.6f, %.6f), got (%.6f, %.6f)\n", 
               expected_x, expected_y, params[0], params[1]);
        return 1;
    }
    
    printf("  PASS: Found minimum at (%.6f, %.6f)\n", params[0], params[1]);
    return 0;
}

// Test 4: Error handling - null parameters
int test_null_parameters() {
    printf("Running test_null_parameters...\n");
    
    double params[1] = {0.0};
    double steps[1] = {0.001};
    
    // Test null params
    bool success = Fmin_Newton_Iteration(1, NULL, quadratic_1d, NULL, steps, 0.0, 10);
    if (success) {
        printf("  FAIL: Should return false for null params\n");
        return 1;
    }
    
    // Test null function
    success = Fmin_Newton_Iteration(1, params, NULL, NULL, steps, 0.0, 10);
    if (success) {
        printf("  FAIL: Should return false for null function\n");
        return 1;
    }
    
    // Test null steps
    success = Fmin_Newton_Iteration(1, params, quadratic_1d, NULL, NULL, 0.0, 10);
    if (success) {
        printf("  FAIL: Should return false for null steps\n");
        return 1;
    }
    
    printf("  PASS: Correctly handled null parameters\n");
    return 0;
}

// Test 5: Error handling - zero parameters or steps
int test_zero_parameters_steps() {
    printf("Running test_zero_parameters_steps...\n");
    
    double params[1] = {0.0};
    double steps[1] = {0.001};
    
    // Test zero parameters
    bool success = Fmin_Newton_Iteration(0, params, quadratic_1d, NULL, steps, 0.0, 10);
    if (success) {
        printf("  FAIL: Should return false for zero parameters\n");
        return 1;
    }
    
    // Test zero steps
    success = Fmin_Newton_Iteration(1, params, quadratic_1d, NULL, steps, 0.0, 0);
    if (success) {
        printf("  FAIL: Should return false for zero steps\n");
        return 1;
    }
    
    printf("  PASS: Correctly handled zero parameters/steps\n");
    return 0;
}

// Test 6: Memory allocation failure simulation
int test_memory_allocation() {
    printf("Running test_memory_allocation...\n");
    // This test would normally require mocking malloc to return NULL
    // For now, we'll just test that the function handles normal allocation
    double params[1] = {0.0};
    double steps[1] = {0.001};
    
    bool success = Fmin_Newton_Iteration(1, params, quadratic_1d, NULL, steps, 0.0, 1);
    
    if (!success) {
        printf("  FAIL: Memory allocation should succeed for small problem\n");
        return 1;
    }
    
    printf("  PASS: Memory allocation test passed\n");
    return 0;
}

// Test case array
test_case_t test_cases[] = {
    {"Quadratic 1D", test_quadratic_1d},
    {"Rosenbrock 2D", test_rosenbrock_2d},
    {"Quadratic 2D with regularization", test_quadratic_2d_with_regularization},
    {"Null parameters handling", test_null_parameters},
    {"Zero parameters/steps handling", test_zero_parameters_steps},
    {"Memory allocation", test_memory_allocation},
    {NULL, NULL}  // Sentinel
};

int main() {
    printf("=== Starting Newton Iteration Tests ===\n\n");
    
    int total_tests = 0;
    int failed_tests = 0;
    
    // Run all tests
    for (int i = 0; test_cases[i].name != NULL; i++) {
        total_tests++;
        printf("Test %d: %s\n", total_tests, test_cases[i].name);
        
        int result = test_cases[i].test_func();
        if (result != 0) {
            failed_tests++;
            global_test_failures++;
        }
        printf("\n");
    }
    
    // Print summary
    printf("=== Test Summary ===\n");
    printf("Total tests: %d\n", total_tests);
    printf("Passed: %d\n", total_tests - failed_tests);
    printf("Failed: %d\n", failed_tests);
    
    if (failed_tests > 0) {
        printf("\n*** Some tests failed. Exiting with failure code. ***\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\nAll tests passed!\n");
        exit(EXIT_SUCCESS);
    }
}