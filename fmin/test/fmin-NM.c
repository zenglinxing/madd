/* coding: utf-8 */
/*
This code is generated by Deepseek
*/
#include <stdio.h>
#include <stdlib.h>
#include <locale.h>
#include <math.h>
#include <wchar.h>
#include "madd.h"

// 抛物线函数: f(x) = (x-3)^2，最小值在x=3处
double parabola(double *params, void *other_param) {
    return pow(params[0] - 3.0, 2);
}

/* 测试目标函数：Rosenbrock函数（经典优化测试函数） */
double rosenbrock(double *params, void *other_param) {
    // Rosenbrock函数: f(x,y) = (a-x)^2 + b(y-x^2)^2
    // 最小值在 (a, a^2) 处，f=0
    double a = 1.0, b = 100.0;
    double x = params[0], y = params[1];
    return pow(a - x, 2) + b * pow(y - x * x, 2);
}

/* 测试目标函数：Sphere函数（简单凸函数） */
double sphere(double *params, void *other_param) {
    // Sphere函数: f(x,y) = x^2 + y^2
    // 最小值在 (0,0) 处，f=0
    double sum = 0.0;
    for (int i = 0; i < 2; i++) {
        sum += params[i] * params[i];
    }
    return sum;
}

int main() {
    // 设置本地化环境以支持宽字符输出
    setlocale(LC_ALL, "");
    
    Madd_Print(L"===== Nelder-Mead算法测试 =====\n");
    
    /* 测试1：Rosenbrock函数优化 */
    {
        Madd_Print(L"\n测试1：Rosenbrock函数优化（预期最小值在(1,1)处）\n");
        
        const int n_param = 2;
        const int n_points = 3; // n+1个点
        double **start = (double**)malloc(n_points*sizeof(double*));
        
        // 分配并初始化单纯形的三个点
        for (int i = 0; i < n_points; i++) {
            start[i] = (double *)malloc(n_param * sizeof(double));
        }
        
        // 设置初始单纯形（包含三个点）
        start[0][0] = 0.0; start[0][1] = 0.0;  // 点1: (0,0)
        start[1][0] = 1.5; start[1][1] = 0.0;  // 点2: (1.5,0)
        start[2][0] = 0.0; start[2][1] = 1.5;  // 点3: (0,1.5)
        
        // 运行Nelder-Mead优化
        int result = Fmin_NM(n_param, start, rosenbrock, NULL, 
                            1000,  // 最大迭代次数
                            0,     // 从第0步开始打印
                            100);  // 每100步打印一次
        
        // 检查结果
        wchar_t info[256];
        double best_x = start[0][0], best_y = start[0][1];
        
        // 寻找最小值点
        for (int i = 0; i < n_points; i++) {
            double current_val = rosenbrock(start[i], NULL);
            if (current_val < rosenbrock((double[]){best_x, best_y}, NULL)) {
                best_x = start[i][0];
                best_y = start[i][1];
            }
        }
        
        swprintf(info, 256, L"优化结果: 找到最小值点 (%f, %f), 函数值 = %f\n", 
                best_x, best_y, rosenbrock((double[]){best_x, best_y}, NULL));
        Madd_Print(info);
        
        // 清理内存
        for (int i = 0; i < n_points; i++) {
            free(start[i]);
        }
        free(start);
    }
    
    /* 测试2：Sphere函数优化 */
    {
        Madd_Print(L"\n测试2：Sphere函数优化（预期最小值在(0,0)处）\n");
        
        const int n_param = 2;
        const int n_points = 3; // n+1个点
        double **start = (double**)malloc(n_points*sizeof(double*));
        
        // 分配并初始化单纯形的三个点
        for (int i = 0; i < n_points; i++) {
            start[i] = (double *)malloc(n_param * sizeof(double));
        }
        
        // 设置初始单纯形（较远的点）
        start[0][0] = 10.0; start[0][1] = 10.0;  // 点1: (10,10)
        start[1][0] = 15.0; start[1][1] = 5.0;   // 点2: (15,5)
        start[2][0] = 5.0;  start[2][1] = 14.0;  // 点3: (5,15)
        
        // 运行Nelder-Mead优化
        int result = Fmin_NM(n_param, start, sphere, NULL, 
                            500,   // 最大迭代次数
                            0,     // 从第0步开始打印
                            50);   // 每50步打印一次
        
        // 检查结果
        wchar_t info[256];
        double best_x = start[0][0], best_y = start[0][1];
        
        // 寻找最小值点
        for (int i = 0; i < n_points; i++) {
            double current_val = sphere(start[i], NULL);
            if (current_val < sphere((double[]){best_x, best_y}, NULL)) {
                best_x = start[i][0];
                best_y = start[i][1];
            }
        }
        
        swprintf(info, 256, L"优化结果: 找到最小值点 (%f, %f), 函数值 = %f\n", 
                best_x, best_y, sphere((double[]){best_x, best_y}, NULL));
        Madd_Print(info);
        
        // 清理内存
        for (int i = 0; i < n_points; i++) {
            free(start[i]);
        }
        free(start);
    }
    
    /* 测试3：边界情况测试（单参数） */
    {
        Madd_Print(L"\n测试3：单参数优化（抛物线函数）\n");
        
        const int n_param = 1;
        const int n_points = 2; // n+1个点
        double **start = (double**)malloc(n_points*sizeof(double*));
        
        // 分配并初始化单纯形的两个点
        for (int i = 0; i < n_points; i++) {
            start[i] = (double *)malloc(n_param * sizeof(double));
        }
        
        // 设置初始单纯形
        start[0][0] = 0.0;  // 点1: x=0
        start[1][0] = 5.0;  // 点2: x=5
        
        // 运行Nelder-Mead优化
        int result = Fmin_NM(n_param, start, parabola, NULL, 
                            100,   // 最大迭代次数
                            0,     // 从第0步开始打印
                            10);   // 每10步打印一次
        
        // 检查结果
        wchar_t info[256];
        double best_x = start[0][0];
        
        // 寻找最小值点
        for (int i = 0; i < n_points; i++) {
            double current_val = parabola(start[i], NULL);
            if (current_val < parabola(&best_x, NULL)) {
                best_x = start[i][0];
            }
        }
        
        swprintf(info, 256, L"优化结果: 找到最小值点 x = %f, 函数值 = %f\n", 
                best_x, parabola(&best_x, NULL));
        Madd_Print(info);
        
        // 清理内存
        for (int i = 0; i < n_points; i++) {
            free(start[i]);
        }
        free(start);
    }
    
    Madd_Print(L"\n===== 测试完成 =====\n");
    
    return 0;
}