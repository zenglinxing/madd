/* coding: utf-8 */
/* coding: utf-8 */
/*
Test code for Fmin_Jacobi_Iteration_Sparse function
This code is generated by Deepseek-R1
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <stdint.h>
#include <stdbool.h>
#include"madd.h"

/* Test utilities */
#define MAX_TEST_NAME_LEN 100
#define TOLERANCE 1e-10

typedef struct {
    char test_name[MAX_TEST_NAME_LEN];
    bool (*test_function)(void);
    bool passed;
} TestCase;

int tests_failed = 0;
int tests_passed = 0;

/* Macro to check test conditions */
#define CHECK(condition, message) \
    do { \
        if (!(condition)) { \
            printf("FAIL: %s\n", message); \
            return false; \
        } \
    } while(0)

#define CHECK_DOUBLE_EQ(actual, expected, tolerance, message) \
    do { \
        double diff = fabs((actual) - (expected)); \
        if (diff > tolerance) { \
            printf("FAIL: %s (expected %.10f, got %.10f, diff %.2e)\n", \
                   message, expected, actual, diff); \
            return false; \
        } \
    } while(0)

/* Test 1: Simple 2x2 diagonal dominant matrix */
bool test_simple_2x2_matrix(void) {
    printf("Running test: Simple 2x2 matrix\n");
    
    /* Create matrix: [4, 1; 1, 3] */
    Sparse_Matrix_COO matrix;
    matrix.dim = 2;
    matrix.n_unit = 4;
    matrix.unit = malloc(4 * sizeof(Sparse_Matrix_COO_Unit));
    
    matrix.unit[0].x = 0; matrix.unit[0].y = 0; matrix.unit[0].value = 4.0;
    matrix.unit[1].x = 0; matrix.unit[1].y = 1; matrix.unit[1].value = 1.0;
    matrix.unit[2].x = 1; matrix.unit[2].y = 0; matrix.unit[2].value = 1.0;
    matrix.unit[3].x = 1; matrix.unit[3].y = 1; matrix.unit[3].value = 3.0;
    
    double b[2] = {1.0, 2.0};  /* Ax = b */
    double solution[2] = {0.0, 0.0};  /* Initial guess */
    
    /* Expected solution: x = [0.0909..., 0.6363...] */
    double expected[2] = {1.0/11.0, 7.0/11.0};
    
    bool result = Fmin_Jacobi_Iteration_Sparse(&matrix, b, solution, 100);
    
    CHECK(result, "Jacobi iteration should succeed for 2x2 matrix");
    CHECK_DOUBLE_EQ(solution[0], expected[0], TOLERANCE, 
                   "First component of solution incorrect");
    CHECK_DOUBLE_EQ(solution[1], expected[1], TOLERANCE,
                   "Second component of solution incorrect");
    
    free(matrix.unit);
    return true;
}

/* Test 2: 3x3 matrix with known solution */
bool test_3x3_matrix(void) {
    printf("Running test: 3x3 matrix\n");
    
    Sparse_Matrix_COO matrix;
    matrix.dim = 3;
    matrix.n_unit = 5;  /* Only store non-zero elements */
    matrix.unit = malloc(5 * sizeof(Sparse_Matrix_COO_Unit));
    
    /* Matrix: [5, 2, 0; 2, 5, 2; 0, 2, 5] */
    matrix.unit[0].x = 0; matrix.unit[0].y = 0; matrix.unit[0].value = 5.0;
    matrix.unit[1].x = 0; matrix.unit[1].y = 1; matrix.unit[1].value = 2.0;
    matrix.unit[2].x = 1; matrix.unit[2].y = 0; matrix.unit[2].value = 2.0;
    matrix.unit[3].x = 1; matrix.unit[3].y = 1; matrix.unit[3].value = 5.0;
    matrix.unit[4].x = 1; matrix.unit[4].y = 2; matrix.unit[4].value = 2.0;
    /* Note: element (2,2) is missing - this is intentional to test sparse storage */
    
    double b[3] = {9.0, 12.0, 9.0};  /* Right-hand side */
    double solution[3] = {0.0, 0.0, 0.0};
    
    /* Expected solution: x = [1, 2, 1] */
    double expected[3] = {1.0, 2.0, 1.0};
    
    bool result = Fmin_Jacobi_Iteration_Sparse(&matrix, b, solution, 100);
    
    /* This test should fail because we're missing diagonal element (2,2) */
    CHECK(!result, "Jacobi iteration should fail for incomplete diagonal");
    
    free(matrix.unit);
    return true;
}

/* Test 3: Matrix with zero diagonal element (should fail) */
bool test_zero_diagonal(void) {
    printf("Running test: Matrix with zero diagonal\n");
    
    Sparse_Matrix_COO matrix;
    matrix.dim = 2;
    matrix.n_unit = 3;
    matrix.unit = malloc(3 * sizeof(Sparse_Matrix_COO_Unit));
    
    /* Matrix with zero diagonal: [0, 1; 1, 2] */
    matrix.unit[0].x = 0; matrix.unit[0].y = 0; matrix.unit[0].value = 0.0;
    matrix.unit[1].x = 0; matrix.unit[1].y = 1; matrix.unit[1].value = 1.0;
    matrix.unit[2].x = 1; matrix.unit[2].y = 1; matrix.unit[2].value = 2.0;
    
    double b[2] = {1.0, 2.0};
    double solution[2] = {0.0, 0.0};
    
    bool result = Fmin_Jacobi_Iteration_Sparse(&matrix, b, solution, 100);
    
    CHECK(!result, "Jacobi iteration should fail for zero diagonal element");
    
    free(matrix.unit);
    return true;
}

/* Test 4: Identity matrix (should converge immediately) */
bool test_identity_matrix(void) {
    printf("Running test: Identity matrix\n");
    
    Sparse_Matrix_COO matrix;
    matrix.dim = 3;
    matrix.n_unit = 3;
    matrix.unit = malloc(3 * sizeof(Sparse_Matrix_COO_Unit));
    
    /* Identity matrix */
    matrix.unit[0].x = 0; matrix.unit[0].y = 0; matrix.unit[0].value = 1.0;
    matrix.unit[1].x = 1; matrix.unit[1].y = 1; matrix.unit[1].value = 1.0;
    matrix.unit[2].x = 2; matrix.unit[2].y = 2; matrix.unit[2].value = 1.0;
    
    double b[3] = {2.0, 4.0, 6.0};
    double solution[3] = {0.0, 0.0, 0.0};
    double expected[3] = {2.0, 4.0, 6.0};
    
    bool result = Fmin_Jacobi_Iteration_Sparse(&matrix, b, solution, 10);
    
    CHECK(result, "Jacobi iteration should succeed for identity matrix");
    CHECK_DOUBLE_EQ(solution[0], expected[0], TOLERANCE, "x0 incorrect for identity matrix");
    CHECK_DOUBLE_EQ(solution[1], expected[1], TOLERANCE, "x1 incorrect for identity matrix");
    CHECK_DOUBLE_EQ(solution[2], expected[2], TOLERANCE, "x2 incorrect for identity matrix");
    
    free(matrix.unit);
    return true;
}

/* Test 5: NULL pointer checks */
bool test_null_pointers(void) {
    printf("Running test: NULL pointer checks\n");
    
    Sparse_Matrix_COO valid_matrix;
    valid_matrix.dim = 2;
    valid_matrix.n_unit = 2;
    valid_matrix.unit = malloc(2 * sizeof(Sparse_Matrix_COO_Unit));
    valid_matrix.unit[0].x = 0; valid_matrix.unit[0].y = 0; valid_matrix.unit[0].value = 1.0;
    valid_matrix.unit[1].x = 1; valid_matrix.unit[1].y = 1; valid_matrix.unit[1].value = 1.0;
    
    double b[2] = {1.0, 1.0};
    double solution[2] = {0.0, 0.0};
    
    /* Test NULL matrix */
    bool result = Fmin_Jacobi_Iteration_Sparse(NULL, b, solution, 10);
    CHECK(!result, "Should fail with NULL matrix");
    
    /* Test NULL b vector */
    result = Fmin_Jacobi_Iteration_Sparse(&valid_matrix, NULL, solution, 10);
    CHECK(!result, "Should fail with NULL b vector");
    
    /* Test NULL solution vector */
    result = Fmin_Jacobi_Iteration_Sparse(&valid_matrix, b, NULL, 10);
    CHECK(!result, "Should fail with NULL solution vector");
    
    free(valid_matrix.unit);
    return true;
}

/* Test 6: Convergence test for larger matrix */
bool test_larger_matrix_convergence(void) {
    printf("Running test: 5x5 matrix convergence\n");
    
    Sparse_Matrix_COO matrix;
    matrix.dim = 5;
    matrix.n_unit = 13;
    matrix.unit = malloc(13 * sizeof(Sparse_Matrix_COO_Unit));
    
    /* Create a 5x5 diagonally dominant matrix */
    int idx = 0;
    for (int i = 0; i < 5; i++) {
        matrix.unit[idx].x = i; matrix.unit[idx].y = i; 
        matrix.unit[idx++].value = 6.0;  /* Strong diagonal */
        
        if (i > 0) {
            matrix.unit[idx].x = i; matrix.unit[idx].y = i-1; 
            matrix.unit[idx++].value = 1.0;
        }
        if (i < 4) {
            matrix.unit[idx].x = i; matrix.unit[idx].y = i+1; 
            matrix.unit[idx++].value = 1.0;
        }
    }
    
    double b[5] = {7.0, 8.0, 8.0, 8.0, 7.0};  /* Chosen so solution is [1,1,1,1,1] */
    double solution[5] = {0.0, 0.0, 0.0, 0.0, 0.0};
    double expected[5] = {1.0, 1.0, 1.0, 1.0, 1.0};
    
    printf("in fmin\n");
    bool result = Fmin_Jacobi_Iteration_Sparse(&matrix, b, solution, 1000);
    
    CHECK(result, "Jacobi iteration should converge for 5x5 matrix");
    
    for (int i = 0; i < 5; i++) {
        char message[50];
        snprintf(message, sizeof(message), "Solution component %d incorrect", i);
        CHECK_DOUBLE_EQ(solution[i], expected[i], 1e-6, message);
    }
    
    free(matrix.unit);
    return true;
}

/* Test runner */
void run_test(TestCase *test) {
    printf("=== Test: %s ===\n", test->test_name);
    test->passed = test->test_function();
    
    if (test->passed) {
        printf("PASS: %s\n\n", test->test_name);
        tests_passed++;
    } else {
        printf("FAIL: %s\n\n", test->test_name);
        tests_failed++;
    }
}

int main(void) {
    printf("Starting tests for Fmin_Jacobi_Iteration_Sparse\n");
    printf("==============================================\n\n");
    
    /* Define test cases */
    TestCase test_cases[] = {
        {"Simple 2x2 matrix", test_simple_2x2_matrix, false},
        {"3x3 matrix with missing diagonal", test_3x3_matrix, false},
        {"Matrix with zero diagonal", test_zero_diagonal, false},
        {"Identity matrix", test_identity_matrix, false},
        {"NULL pointer checks", test_null_pointers, false},
        {"5x5 matrix convergence", test_larger_matrix_convergence, false}
    };
    
    int num_tests = sizeof(test_cases) / sizeof(test_cases[0]);
    
    /* Run all tests */
    for (int i = 0; i < num_tests; i++) {
        run_test(&test_cases[i]);
    }
    
    /* Print summary */
    printf("==============================================\n");
    printf("Test Summary:\n");
    printf("Total tests: %d\n", num_tests);
    printf("Passed: %d\n", tests_passed);
    printf("Failed: %d\n", tests_failed);
    
    if (tests_failed > 0) {
        printf("\n*** Some tests failed. Exiting with failure code. ***\n");
        exit(EXIT_FAILURE);
    } else {
        printf("\nAll tests passed successfully!\n");
        exit(EXIT_SUCCESS);
    }
}