\chapter{sort}

There are multiple prevalent sort algorithm implemented in Madd. As listed in Table

\begin{table}[htbp]
  \centering
  \caption{Sort algorithms}\label{table: sort algorithm}
  \begin{tabular}{cccccc}
    \hline\hline
    \multirow{2}*{sort type} & \multirow{2}*{algorithm} & \multicolumn{2}{c}{time complexity} & \multirow{2}*{space complexity} & \multirow{2}*{stability} \\
    {} & {} & best & worst & {} & {} \\
    \hline
    integer & counting sort & $O(n+k)$ & $O(n+k)$ & $O(k)$ & Y \\
    \hline
    compare & heap sort & $O(n\log n)$ & $O(n\log n)$ & $O(1)$ & N \\
    {} & insertion sort & $O(n)$ & $O(n^{2})$ & $O(1)$ & Y \\
    {} & merge sort & $O(n\log n)$ & $O(n\log n)$ & $O(n)$ & Y \\
    {} & quick sort & $O(n\log n)$ & $O(n^{2})$ & $O(\log n)$ & Y \\
    {} & shell sort & $O(n^{7/6})$ & $O(n^4/3)$ & O(1) & N \\
    \hline\hline
  \end{tabular}
\end{table} 

Note that the shell sort function in Madd uses Sedgewick sequence, so the time complexity is smaller than what you learn from the textbook. 

The sort type indicates the type of sorted element.
If the sort type is integer, the algorithm just sort the integer.
If the sort type is compare, then you can sort any types of element.

For the algorithms sorting integer, you should prepare a get-key function.
For algorithms sorting any types, you should prepare a compare function.
They should be declared as follows.
{\it get\_key} returns an integer represents the given element.
{\it compare\_func} returns true if a is \emph{less than} or \emph{equal to b}.

\begin{lstlisting}[language=C, title={Declarations of functions for sorting.},]
uint64_t get_key(void *element, void *other_param);
bool compare_func(void *a, void *b, void *other_param);
\end{lstlisting}

\section{Declaration of Sort Functions}

\begin{lstlisting}[language=C, title={Declarations of sort functions.},]
void Sort_Counting(uint64_t n_element, size_t usize, void *arr_,
                   uint64_t get_key(void *element, void *other_param), void *other_param);

void Sort_Insertion(uint64_t n_element, size_t usize, void *arr_,
                    bool func_compare(void *a1, void *a2, void *other_param), void *other_param);
void Sort_Merge(uint64_t n_element, size_t usize, void *arr_,
                bool func_compare(void *a1, void *a2, void *other_param), void *other_param);
void Sort_Quicksort(uint64_t n_element, size_t usize, void *arr_,
                    bool func_compare(void *a, void *b, void *other_param), void *other_param);
void Sort_Shell(uint64_t n_element, size_t usize, void *arr_,
                bool func_compare(void*, void*, void*), void *other_param);
void Sort_Heap_Internal(uint64_t n, size_t usize, void *arr_,
                        bool func_compare(void*, void*, void*), void *other_param,
                        void *ptemp);
void Sort_Heap(uint64_t n, size_t usize, void *arr_,
                    bool func_compare(void*, void*, void*), void *other_param);
\end{lstlisting} 

{\it arr\_} is the pointer to your array. {\it usize} is the size of element.

The function {\it Sort\_Heap\_Internal} has one more parameter than {\it Sort\_Heap} *ptemp.
I suppose you had prepare memory space of *ptemp by {\it usize} bytes.

\section{get-key function to compare function}

You may be upset with transfering get-key function to compare function.
Madd has already implements a function to replace your get-key to compare.

\begin{lstlisting}[language=C, title={get-key function to compare function.},]
typedef struct{
    uint64_t (*get_key_func)(void*, void*);
    void *other_param;
} Sort_Key_Func_to_Compare_Func_Param;

bool Sort_Key_Func_to_Compare_Func(void *a, void *b, void *input_param);
\end{lstlisting}

\begin{lstlisting}[language=C, title={Example of get-key function to compare function.},]
#include<madd.h>
uint64_t get_key(void *a, void *other_param)
{
    uint64_t *aa = (uint64_t)a;
    return *aa;
}

int main(int argc, char *argv[])
{
    uint64_t arr[4] = {1, 2, 3, 4};
    Sort_Counting(arr, 4, sizeof(uint64_t), NULL);
    
    Sort_Key_Func_to_Compare_Func_Param *param = {.get_key_func=get_key, .other_param=NULL};
    Sort_Merge(arr, 4, sizeof(uint64_t), Sort_Key_Func_to_Compare_Func, param);
    return 0;
}
\end{lstlisting}

\section{Binary Search}

\begin{lstlisting}[language=C, title={Binary search functions.},]
uint64_t Binary_Search(uint64_t n, size_t usize, void *arr_, void *element,
                       char func_compare(void *a, void *b, void *other_param), void *other_param);
uint64_t Binary_Search_Insert(uint64_t n, size_t usize, void *arr_, void *element,
                              bool func_compare(void *a, void *b, void *other_param), void *other_param);
\end{lstlisting}

The binary-search is an efficient method to search for element in a \textbf{sorted} array.
{\it Binary\_Search} searches for the element in array, and returns where it is.
If the element is not found, it will returns the possible (maybe not accurate) place to insert the element and pops warning to Madd.
{\it Binary\_Search\_Insert} returns where to insert the element.

Important difference! {\it func\_compare} you provide to {\it Binary\_Search} should only return {\it MADD\_LESS}/{\it MADD\_SAME}/{\it MADD\_GREATER}.