/* coding: utf-8 */
/*
generated by Deepseek-R1
*/
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <math.h>
#include <float.h>
#include "madd.h"

// 测试辅助函数：检查并打印结果
void check_double(double x, uint64_t expected, const char* description) {
    uint64_t result = Hash_IEEE754_double_to_uint64(x);
    int pass = (result == expected);
    
    printf("测试 %-30s: ", description);
    printf("%s ", pass ? "✓" : "✗");
    printf("输入: %-15g 预期: 0x%016llX 实际: 0x%016llX\n", 
           x, (unsigned long long)expected, (unsigned long long)result);
}

void check_float(float x, uint32_t expected, const char* description) {
    uint32_t result = Hash_IEEE754_float_to_uint32(x);
    int pass = (result == expected);
    
    printf("测试 %-30s: ", description);
    printf("%s ", pass ? "✓" : "✗");
    printf("输入: %-15g 预期: 0x%08X 实际: 0x%08X\n", 
           (double)x, expected, result);
}

// 测试双精度映射函数
void test_double_mapping() {
    printf("\n===== 测试双精度浮点数映射 =====\n");
    
    // 特殊值
    check_double(-INFINITY, 0x000FFFFFFFFFFFFFULL, "负无穷");
    check_double(INFINITY, 0xFFF0000000000000ULL, "正无穷");
    check_double(-0.0, 0x8000000000000000ULL, "负零");
    check_double(0.0, 0x8000000000000000ULL, "正零");
    check_double(NAN, Hash_IEEE754_double_to_uint64(NAN), "NaN"); // NaN映射值实现定义
    
    // 边界值
    check_double(-DBL_MAX, 0x000FFFFFFFFFFFFFULL + 1, "最小规格化负数");
    check_double(DBL_MIN, 0x8000000000000000ULL + 1, "最小正规格化数");
    check_double(DBL_MAX, 0xFFEFFFFFFFFFFFFFULL, "最大正规格化数");
    
    // 普通值
    check_double(-2.0, 0x3FFFFFFFFFFFFFFFULL, "-2.0");
    check_double(-1.0, 0x400FFFFFFFFFFFFFULL, "-1.0");
    check_double(-0.5, 0x5FE0000000000000ULL, "-0.5");
    check_double(0.5, 0xBFE0000000000000ULL, "0.5");
    check_double(1.0, 0xBFF0000000000000ULL, "1.0");
    check_double(2.0, 0xC000000000000000ULL, "2.0");
    
    // 非规格化数
    double denorm = ldexp(1.0, -1074); // 最小非规格化数
    check_double(-denorm, 0x7FFFFFFFFFFFFFFFULL, "最小负非规格化数");
    check_double(denorm, 0x8000000000000001ULL, "最小正非规格化数");
}

// 测试单精度映射函数
void test_float_mapping() {
    printf("\n===== 测试单精度浮点数映射 =====\n");
    
    // 特殊值
    check_float(-INFINITY, 0x007FFFFF, "负无穷");
    check_float(INFINITY, 0xFF800000, "正无穷");
    check_float(-0.0f, 0x80000000, "负零");
    check_float(0.0f, 0x80000000, "正零");
    check_float(NAN, 0xFFFFFFFF, "NaN");
    
    // 边界值
    check_float(-FLT_MAX, 0x007FFFFF + 1, "最小规格化负数");
    check_float(FLT_MIN, 0x80000000 + 1, "最小正规格化数");
    check_float(FLT_MAX, 0xFF7FFFFF, "最大正规格化数");
    
    // 普通值
    check_float(-2.0f, 0x3FFFFFFF, "-2.0");
    check_float(-1.0f, 0x407FFFFF, "-1.0");
    check_float(-0.5f, 0x5F000000, "-0.5");
    check_float(0.5f, 0xBF000000, "0.5");
    check_float(1.0f, 0xBF800000, "1.0");
    check_float(2.0f, 0xC0000000, "2.0");
    
    // 非规格化数
    float denorm = ldexp(1.0f, -149); // 最小非规格化数
    check_float(-denorm, 0x7FFFFF, "最小负非规格化数");
    check_float(denorm, 0x800001, "最小正非规格化数");
}

// 测试单调性
void test_monotonicity() {
    printf("\n===== 测试单调性 =====\n");
    
    // 双精度单调性测试
    double double_values[] = {
        -INFINITY, -1000.0, -2.0, -1.0, -0.5, -DBL_MIN, 
        -0.0, 0.0, DBL_MIN, 0.5, 1.0, 2.0, 1000.0, INFINITY
    };
    int double_count = sizeof(double_values) / sizeof(double_values[0]);
    
    printf("双精度单调性测试:\n");
    uint64_t prev = 0;
    for (int i = 0; i < double_count; i++) {
        uint64_t current = Hash_IEEE754_double_to_uint64(double_values[i]);
        int valid = (i == 0) || (current > prev);
        
        printf("  %2d: %-15g -> 0x%016llX %s\n", 
               i, double_values[i], (unsigned long long)current,
               valid ? "✓" : (isnan(double_values[i]) ? "N/A" : "✗"));
        
        if (!isnan(double_values[i])) prev = current;
    }
    
    // 单精度单调性测试
    float float_values[] = {
        -INFINITY, -1000.0f, -2.0f, -1.0f, -0.5f, -FLT_MIN, 
        -0.0f, 0.0f, FLT_MIN, 0.5f, 1.0f, 2.0f, 1000.0f, INFINITY
    };
    int float_count = sizeof(float_values) / sizeof(float_values[0]);
    
    printf("\n单精度单调性测试:\n");
    uint32_t prev32 = 0;
    for (int i = 0; i < float_count; i++) {
        uint32_t current = Hash_IEEE754_float_to_uint32(float_values[i]);
        int valid = (i == 0) || (current > prev32);
        
        printf("  %2d: %-15g -> 0x%08X %s\n", 
               i, (double)float_values[i], current,
               valid ? "✓" : (isnan(float_values[i]) ? "N/A" : "✗"));
        
        if (!isnan(float_values[i])) prev32 = current;
    }
}

int main() {
    test_double_mapping();
    test_float_mapping();
    test_monotonicity();
    return 0;
}