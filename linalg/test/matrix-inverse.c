/* coding: utf-8 */
/*
This code is generated by Deepseek-R1
Test code for matrix inverse functions
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include<madd.h>

#define TOLERANCE 1e-10

// Global variable to track test failures
int test_failures = 0;

// Function to compare two double values with tolerance
int double_equal(double a, double b, double tolerance) {
    return fabs(a - b) < tolerance;
}

// Function to compare two complex numbers with tolerance
int cnum_equal(Cnum a, Cnum b, double tolerance) {
    return double_equal(a.real, b.real, tolerance) && 
           double_equal(a.imag, b.imag, tolerance);
}

// Function to compare two matrices
int matrix_equal(int n, double *A, double *B, double tolerance) {
    for (int i = 0; i < n * n; i++) {
        if (!double_equal(A[i], B[i], tolerance)) {
            return 0;
        }
    }
    return 1;
}

// Function to compare two complex matrices
int matrix_equal_c64(int n, Cnum *A, Cnum *B, double tolerance) {
    for (int i = 0; i < n * n; i++) {
        if (!cnum_equal(A[i], B[i], tolerance)) {
            return 0;
        }
    }
    return 1;
}

// Function to print a matrix
void print_matrix(int n, double *matrix) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf("%8.4f ", matrix[i * n + j]);
        }
        printf("\n");
    }
}

// Function to print a complex matrix
void print_matrix_c64(int n, Cnum *matrix) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            Cnum elem = matrix[i * n + j];
            printf("(%6.3f + %6.3fi) ", elem.real, elem.imag);
        }
        printf("\n");
    }
}

// Test for identity matrix inverse (real case)
void test_identity_matrix_inverse() {
    printf("Testing identity matrix inverse (real)...\n");
    
    int n = 3;
    double identity[9] = {
        1.0, 0.0, 0.0,
        0.0, 1.0, 0.0,
        0.0, 0.0, 1.0
    };
    
    double matrix[9];
    memcpy(matrix, identity, sizeof(identity));
    
    if (!Matrix_Inverse(n, matrix)) {
        printf("ERROR: Failed to compute inverse of identity matrix\n");
        test_failures++;
        return;
    }
    
    if (!matrix_equal(n, matrix, identity, TOLERANCE)) {
        printf("ERROR: Inverse of identity matrix is not itself\n");
        printf("Expected:\n");
        print_matrix(n, identity);
        printf("Got:\n");
        print_matrix(n, matrix);
        test_failures++;
    } else {
        printf("PASS: Identity matrix inverse test\n");
    }
}

// Test for 2x2 matrix inverse (real case)
void test_2x2_matrix_inverse() {
    printf("Testing 2x2 matrix inverse (real)...\n");
    
    int n = 2;
    double matrix[4] = {
        4.0, 7.0,
        2.0, 6.0
    };
    
    double expected_inverse[4] = {
        0.6, -0.7,
        -0.2, 0.4
    };
    
    if (!Matrix_Inverse(n, matrix)) {
        printf("ERROR: Failed to compute inverse of 2x2 matrix\n");
        test_failures++;
        return;
    }
    
    if (!matrix_equal(n, matrix, expected_inverse, TOLERANCE)) {
        printf("ERROR: Inverse of 2x2 matrix is incorrect\n");
        printf("Expected:\n");
        print_matrix(n, expected_inverse);
        printf("Got:\n");
        print_matrix(n, matrix);
        test_failures++;
    } else {
        printf("PASS: 2x2 matrix inverse test\n");
    }
}

// Test for singular matrix (real case)
void test_singular_matrix() {
    printf("Testing singular matrix (real)...\n");
    
    int n = 2;
    double matrix[4] = {
        1.0, 2.0,
        2.0, 4.0  // This matrix is singular (rows are linearly dependent)
    };
    
    if (Matrix_Inverse(n, matrix)) {
        printf("ERROR: Singular matrix inversion should have failed but didn't\n");
        test_failures++;
    } else {
        printf("PASS: Singular matrix correctly failed inversion\n");
    }
}

// Test for identity matrix inverse (complex case)
void test_identity_matrix_inverse_c64() {
    printf("Testing identity matrix inverse (complex)...\n");
    
    int n = 2;
    Cnum identity[4];
    for (int i = 0; i < n * n; i++) {
        identity[i] = Cnum_Value((i % (n+1) == 0) ? 1.0 : 0.0, 0.0);
    }
    
    Cnum matrix[4];
    memcpy(matrix, identity, sizeof(identity));
    
    if (!Matrix_Inverse_c64(n, matrix)) {
        printf("ERROR: Failed to compute inverse of identity matrix (complex)\n");
        test_failures++;
        return;
    }
    
    if (!matrix_equal_c64(n, matrix, identity, TOLERANCE)) {
        printf("ERROR: Inverse of identity matrix is not itself (complex)\n");
        printf("Expected:\n");
        print_matrix_c64(n, identity);
        printf("Got:\n");
        print_matrix_c64(n, matrix);
        test_failures++;
    } else {
        printf("PASS: Identity matrix inverse test (complex)\n");
    }
}

// Test for 2x2 matrix inverse (complex case)
void test_2x2_matrix_inverse_c64() {
    printf("Testing 2x2 matrix inverse (complex)...\n");
    
    int n = 2;
    Cnum matrix[4] = {
        Cnum_Value(1.0, 2.0), Cnum_Value(3.0, 4.0),
        Cnum_Value(5.0, 6.0), Cnum_Value(7.0, 8.0)
    };
    
    // Precomputed inverse using numpy:
    // matrix = np.array([[1+2j, 3+4j], [5+6j, 7+8j]])
    // inverse = np.linalg.inv(matrix)
    Cnum expected_inverse[4] = {
        Cnum_Value(-0.5, 0.4375), Cnum_Value(0.25, -0.1875),
        Cnum_Value(0.375, -0.3125), Cnum_Value(-0.125, 0.0625)
    };
    
    if (!Matrix_Inverse_c64(n, matrix)) {
        printf("ERROR: Failed to compute inverse of 2x2 complex matrix\n");
        test_failures++;
        return;
    }
    
    if (!matrix_equal_c64(n, matrix, expected_inverse, TOLERANCE)) {
        printf("ERROR: Inverse of 2x2 complex matrix is incorrect\n");
        printf("Expected:\n");
        print_matrix_c64(n, expected_inverse);
        printf("Got:\n");
        print_matrix_c64(n, matrix);
        test_failures++;
    } else {
        printf("PASS: 2x2 complex matrix inverse test\n");
    }
}

// Test for singular matrix (complex case)
void test_singular_matrix_c64() {
    printf("Testing singular matrix (complex)...\n");
    
    int n = 2;
    Cnum matrix[4] = {
        Cnum_Value(1.0, 2.0), Cnum_Value(2.0, 4.0),
        Cnum_Value(2.0, 4.0), Cnum_Value(4.0, 8.0)  // This matrix is singular
    };
    
    if (Matrix_Inverse_c64(n, matrix)) {
        printf("ERROR: Singular complex matrix inversion should have failed but didn't\n");
        test_failures++;
    } else {
        printf("PASS: Singular complex matrix correctly failed inversion\n");
    }
}

int main() {
    printf("Starting matrix inverse tests...\n\n");
    
    // Run all tests
    test_identity_matrix_inverse();
    printf("\n");
    
    test_2x2_matrix_inverse();
    printf("\n");
    
    test_singular_matrix();
    printf("\n");
    
    test_identity_matrix_inverse_c64();
    printf("\n");
    
    test_2x2_matrix_inverse_c64();
    printf("\n");
    
    test_singular_matrix_c64();
    printf("\n");
    
    // Print summary
    printf("Test Summary:\n");
    printf("Total tests run: 6\n");
    printf("Failures: %d\n", test_failures);
    
    if (test_failures > 0) {
        printf("Some tests failed. Exiting with failure code.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("All tests passed!\n");
    }
    
    return 0;
}