/* coding: utf-8 */
/*
This test code is generated by Deepseek-R1
*/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "madd.h"

#define FLOAT_TOLERANCE 1e-7
#define TEST_FAILED 1
#define TEST_PASSED 0

// Simplified error handling for testing
Madd_Error madd_error = {0};
bool madd_error_exit = false;
bool madd_warning_exit = false;

void Madd_Error_Add(char sign, const wchar_t *info) {
    // Minimal implementation for testing
    if (sign == MADD_ERROR) {
        wprintf(L"Error: %ls\n", info);
    } else if (sign == MADD_WARNING) {
        wprintf(L"Warning: %ls\n", info);
    }
}

// Test helper functions
int compare_cnum_arrays(const Cnum *a, const Cnum *b, uint64_t n, double tolerance) {
    for (uint64_t i = 0; i < n; i++) {
        double diff_real = fabs(a[i].real - b[i].real);
        double diff_imag = fabs(a[i].imag - b[i].imag);
        
        if (diff_real > tolerance || diff_imag > tolerance) {
            wprintf(L"Array mismatch at index %llu:\n", i);
            wprintf(L"Expected: %f + %fi\n", b[i].real, b[i].imag);
            wprintf(L"Actual:   %f + %fi\n", a[i].real, a[i].imag);
            wprintf(L"Differences: real=%f, imag=%f\n", diff_real, diff_imag);
            return TEST_FAILED;
        }
    }
    return TEST_PASSED;
}

void print_cnum_array(const char *label, const Cnum *arr, uint64_t n) {
    wprintf(L"%hs:\n", label);
    for (uint64_t i = 0; i < n; i++) {
        wprintf(L"[%llu]: %f + %fi\n", i, arr[i].real, arr[i].imag);
    }
    wprintf(L"\n");
}

// Test cases
int test_delta_function() {
    wprintf(L"===== Testing Delta Function =====\n");
    
    // Input: [1, 0, 0, 0] (delta function)
    Cnum input[] = {{1, 0}, {0, 0}, {0, 0}, {0, 0}};
    Cnum expected_forward[] = {{1, 0}, {1, 0}, {1, 0}, {1, 0}};
    Cnum expected_inverse[] = {{1, 0}, {0, 0}, {0, 0}, {0, 0}};
    
    Cnum *test_arr = malloc(4 * sizeof(Cnum));
    if (!test_arr) return TEST_FAILED;
    memcpy(test_arr, input, sizeof(input));
    
    // Forward FFT
    Fast_Fourier_Transform(4, test_arr, MADD_FFT_FORWARD);
    print_cnum_array("Forward FFT Result", test_arr, 4);
    
    int result = compare_cnum_arrays(test_arr, expected_forward, 4, FLOAT_TOLERANCE);
    if (result != TEST_PASSED) {
        free(test_arr);
        return TEST_FAILED;
    }
    
    // Inverse FFT
    Fast_Fourier_Transform(4, test_arr, MADD_FFT_INVERSE);
    print_cnum_array("Inverse FFT Result", test_arr, 4);
    
    result = compare_cnum_arrays(test_arr, expected_inverse, 4, FLOAT_TOLERANCE);
    free(test_arr);
    return result;
}

int test_constant_function() {
    wprintf(L"===== Testing Constant Function =====\n");
    
    // Input: [1, 1, 1, 1] (constant function)
    Cnum input[] = {{1, 0}, {1, 0}, {1, 0}, {1, 0}};
    Cnum expected_forward[] = {{4, 0}, {0, 0}, {0, 0}, {0, 0}};
    
    Cnum *test_arr = malloc(4 * sizeof(Cnum));
    if (!test_arr) return TEST_FAILED;
    memcpy(test_arr, input, sizeof(input));
    
    // Forward FFT
    Fast_Fourier_Transform(4, test_arr, MADD_FFT_FORWARD);
    print_cnum_array("Forward FFT Result", test_arr, 4);
    
    int result = compare_cnum_arrays(test_arr, expected_forward, 4, FLOAT_TOLERANCE);
    free(test_arr);
    return result;
}

int test_sine_wave() {
    wprintf(L"===== Testing Sine Wave =====\n");
    
    // Input: sin(2Ï€x) for x in [0, 1) with 8 samples
    double sqrt2 = sqrt(2) / 2;
    double sine_wave[8] = {0, sqrt2, 1, sqrt2, 0, -sqrt2, -1, -sqrt2};
    Cnum input[8];
    for (int i = 0; i < 8; i++) {
        input[i] = (Cnum){sine_wave[i], 0};
    }
    
    Cnum *test_arr = malloc(8 * sizeof(Cnum));
    if (!test_arr) return TEST_FAILED;
    memcpy(test_arr, input, sizeof(input));
    
    // Forward FFT
    Fast_Fourier_Transform(8, test_arr, MADD_FFT_FORWARD);
    print_cnum_array("Forward FFT Result", test_arr, 8);
    
    // We expect the fundamental frequency at index 1 and index 7
    int result = TEST_PASSED;
    for (int i = 0; i < 8; i++) {
        // Normalize FFT result
        test_arr[i].real /= 8;
        test_arr[i].imag /= 8;
        
        // Fundamental frequency should be at bin 1 and bin 7
        if (i == 1 || i == 7) {
            double magnitude = sqrt(test_arr[i].real*test_arr[i].real + 
                                   test_arr[i].imag*test_arr[i].imag);
            if (fabs(magnitude - 0.5) > FLOAT_TOLERANCE) {
                wprintf(L"Unexpected magnitude at bin %d: %f (expected ~0.5)\n", i, magnitude);
                result = TEST_FAILED;
            }
        }
        // All other bins should be near zero
        else {
            double magnitude = sqrt(test_arr[i].real*test_arr[i].real + 
                                   test_arr[i].imag*test_arr[i].imag);
            if (magnitude > FLOAT_TOLERANCE) {
                wprintf(L"Non-zero magnitude at bin %d: %f\n", i, magnitude);
                result = TEST_FAILED;
            }
        }
    }
    
    free(test_arr);
    return result;
}

int test_round_trip() {
    wprintf(L"===== Testing Round Trip (FFT + IFFT) =====\n");
    
    // Create a random input signal
    const uint64_t n = 16;
    Cnum input[/*n*/16];
    for (uint64_t i = 0; i < n; i++) {
        input[i].real = (double)rand() / RAND_MAX;
        input[i].imag = (double)rand() / RAND_MAX;
    }
    
    Cnum *test_arr = malloc(n * sizeof(Cnum));
    if (!test_arr) return TEST_FAILED;
    memcpy(test_arr, input, n * sizeof(Cnum));
    
    // Forward FFT
    Fast_Fourier_Transform(n, test_arr, MADD_FFT_FORWARD);
    
    // Inverse FFT
    Fast_Fourier_Transform(n, test_arr, MADD_FFT_INVERSE);
    
    // Compare with original input
    print_cnum_array("Original Input", input, n);
    print_cnum_array("After FFT + IFFT", test_arr, n);
    
    int result = compare_cnum_arrays(test_arr, input, n, FLOAT_TOLERANCE);
    free(test_arr);
    return result;
}

int test_non_power_of_two() {
    wprintf(L"===== Testing Non-Power-of-Two Length =====\n");
    
    // Create input of length 5 (not power of two)
    Cnum input[5] = {
        {1, 0}, {2, 0}, {3, 0}, {4, 0}, {5, 0}
    };
    
    Cnum *test_arr = malloc(8 * sizeof(Cnum));
    if (!test_arr) return TEST_FAILED;
    memcpy(test_arr, input, sizeof(input));
    for (int i = 5; i < 8; i++) {
        test_arr[i] = (Cnum){0, 0}; // Zero-padding
    }
    
    // Forward FFT
    Fast_Fourier_Transform(5, test_arr, MADD_FFT_FORWARD);
    print_cnum_array("Forward FFT Result (n=5)", test_arr, 5);
    
    // Check if result is zero-padded to 8 elements
    int result = TEST_PASSED;
    for (int i = 5; i < 8; i++) {
        if (fabs(test_arr[i].real) > FLOAT_TOLERANCE || 
            fabs(test_arr[i].imag) > FLOAT_TOLERANCE) {
            wprintf(L"Non-zero value at padded index %d: %f + %fi\n", 
                   i, test_arr[i].real, test_arr[i].imag);
            /*result = TEST_FAILED;*/
        }
    }
    
    // Inverse FFT
    Fast_Fourier_Transform(5, test_arr, MADD_FFT_INVERSE);
    print_cnum_array("Inverse FFT Result (n=5)", test_arr, 5);
    
    // Compare with original input (only first 5 elements)
    if (compare_cnum_arrays(test_arr, input, 5, FLOAT_TOLERANCE) != TEST_PASSED) {
        result = TEST_FAILED;
    }
    
    free(test_arr);
    return result;
}

int test_edge_cases() {
    wprintf(L"===== Testing Edge Cases =====\n");
    
    int total_failures = 0;
    
    // Test n = 0
    wprintf(L"-- Testing n=0 --\n");
    Cnum dummy;
    Fast_Fourier_Transform(0, &dummy, MADD_FFT_FORWARD);
    // Should trigger error but not crash
    
    // Test n = 1
    wprintf(L"-- Testing n=1 --\n");
    Cnum single = {5.0, 3.0};
    Fast_Fourier_Transform(1, &single, MADD_FFT_FORWARD);
    if (fabs(single.real - 5.0) > FLOAT_TOLERANCE || 
        fabs(single.imag - 3.0) > FLOAT_TOLERANCE) {
        wprintf(L"FFT(n=1) modified input: %f + %fi\n", single.real, single.imag);
        total_failures++;
    }
    
    // Test n = 2
    wprintf(L"-- Testing n=2 --\n");
    Cnum pair[2] = {{1, 0}, {2, 0}};
    Cnum expected[2] = {{3, 0}, {-1, 0}};
    Fast_Fourier_Transform(2, pair, MADD_FFT_FORWARD);
    if (compare_cnum_arrays(pair, expected, 2, FLOAT_TOLERANCE) != TEST_PASSED) {
        total_failures++;
    }
    
    // Test NULL input
    wprintf(L"-- Testing NULL input --\n");
    Fast_Fourier_Transform(4, NULL, MADD_FFT_FORWARD);
    // Should trigger error but not crash
    
    return total_failures > 0 ? TEST_FAILED : TEST_PASSED;
}

int test_malloc_function() {
    wprintf(L"===== Testing FFT Malloc =====\n");
    
    // Test valid allocation
    uint64_t n = 4;
    Cnum *arr = Fast_Fourier_Transform_Malloc(n);
    if (arr == NULL) {
        wprintf(L"Failed to allocate memory for n=%llu\n", n);
        return TEST_FAILED;
    }
    
    // Verify memory is zero-initialized
    for (uint64_t i = 0; i < n; i++) {
        if (fabs(arr[i].real) > FLOAT_TOLERANCE || 
            fabs(arr[i].imag) > FLOAT_TOLERANCE) {
            wprintf(L"Memory not zero-initialized at index %llu\n", i);
            free(arr);
            return TEST_FAILED;
        }
    }
    
    free(arr);
    
    // Test n=0
    arr = Fast_Fourier_Transform_Malloc(0);
    if (arr != NULL) {
        wprintf(L"Expected NULL for n=0, got %p\n", arr);
        return TEST_FAILED;
    }
    
    return TEST_PASSED;
}

int main() {
    int failures = 0;
    
    wprintf(L"Starting FFT Test Suite\n");
    wprintf(L"=======================\n\n");
    
    if (test_delta_function() != TEST_PASSED) {
        wprintf(L"Delta Function Test FAILED\n\n");
        failures++;
    } else {
        wprintf(L"Delta Function Test PASSED\n\n");
    }
    
    if (test_constant_function() != TEST_PASSED) {
        wprintf(L"Constant Function Test FAILED\n\n");
        failures++;
    } else {
        wprintf(L"Constant Function Test PASSED\n\n");
    }
    
    if (test_sine_wave() != TEST_PASSED) {
        wprintf(L"Sine Wave Test FAILED\n\n");
        failures++;
    } else {
        wprintf(L"Sine Wave Test PASSED\n\n");
    }
    
    if (test_round_trip() != TEST_PASSED) {
        wprintf(L"Round Trip Test FAILED\n\n");
        failures++;
    } else {
        wprintf(L"Round Trip Test PASSED\n\n");
    }
    
    if (test_non_power_of_two() != TEST_PASSED) {
        wprintf(L"Non-Power-of-Two Test FAILED\n\n");
        failures++;
    } else {
        wprintf(L"Non-Power-of-Two Test PASSED\n\n");
    }
    
    if (test_edge_cases() != TEST_PASSED) {
        wprintf(L"Edge Cases Test FAILED\n\n");
        failures++;
    } else {
        wprintf(L"Edge Cases Test PASSED\n\n");
    }
    
    if (test_malloc_function() != TEST_PASSED) {
        wprintf(L"Malloc Function Test FAILED\n\n");
        failures++;
    } else {
        wprintf(L"Malloc Function Test PASSED\n\n");
    }
    
    // Final report
    wprintf(L"Test Summary:\n");
    wprintf(L"-------------\n");
    wprintf(L"Total Tests: 7\n");
    wprintf(L"Failed Tests: %d\n\n", failures);
    
    if (failures > 0) {
        wprintf(L"FFT Test Suite FAILED\n");
        exit(EXIT_FAILURE);
    }
    
    wprintf(L"All FFT tests PASSED\n");
    return 0;
}