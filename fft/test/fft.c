/* coding: utf-8 */
/*
This test code is generated by Doubao-AI
*/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "madd.h"  // Assume this includes fft.h, cnum.h, basic.h, etc.

// Tolerance for floating-point comparisons (adjust based on precision needs)
#define TOLERANCE 1e-6

// Global error flag to track test failures
static int test_failed = 0;

// Print test status message
static void print_test_status(const char *test_name, int passed) {
    if (passed) {
        printf("Test '%s': PASSED\n", test_name);
    } else {
        printf("Test '%s': FAILED\n", test_name);
        test_failed = 1;
    }
}

// Test 1: FFT of a delta function (input: [1, 0, 0, ..., 0])
// Expected result: All elements should be 1.0 after FFT
static void test_delta_function() {
    const uint64_t n = 8;  // Power of 2 for basic test
    Cnum *input = (Cnum*)Fast_Fourier_Transform_Malloc(n);
    if (input == NULL) {
        printf("Test 'delta_function': Memory allocation failed\n");
        test_failed = 1;
        return;
    }

    // Initialize delta function: input[0] = 1, others = 0
    input[0] = Cnum_Value(1.0, 0.0);
    for (uint64_t i = 1; i < n; i++) {
        input[i] = Cnum_Value(0.0, 0.0);
    }

    // Perform FFT
    Fast_Fourier_Transform(n, input, MADD_FFT_FORWARD);

    // Check if all elements are approximately 1.0
    int passed = 1;
    for (uint64_t i = 0; i < n; i++) {
        double real_err = fabs(input[i].real - 1.0);
        double imag_err = fabs(input[i].imag);
        if (real_err > TOLERANCE || imag_err > TOLERANCE) {
            passed = 0;
            printf("  Mismatch at index %llu: real=%.6f (expected 1.0), imag=%.6f (expected 0.0)\n",
                   (unsigned long long)i, input[i].real, input[i].imag);
            break;
        }
    }

    print_test_status("delta_function", passed);
    free(input);
}

// Test 2: Inverse FFT should reconstruct original signal
// Process: FFT -> IFFT, check if result matches original
static void test_fft_ifft_consistency() {
    const uint64_t n = 16;  // Power of 2
    Cnum *input = (Cnum*)malloc(n * sizeof(Cnum));
    Cnum *original = (Cnum*)malloc(n * sizeof(Cnum));
    if (input == NULL || original == NULL) {
        printf("Test 'fft_ifft_consistency': Memory allocation failed\n");
        test_failed = 1;
        free(input);
        free(original);
        return;
    }

    // Generate a random test signal (real-valued for simplicity)
    for (uint64_t i = 0; i < n; i++) {
        original[i] = Cnum_Value((double)i / n, 0.0);  // Simple linear signal
        input[i] = original[i];  // Copy to input
    }

    // Perform FFT then IFFT
    Fast_Fourier_Transform(n, input, MADD_FFT_FORWARD);
    Fast_Fourier_Transform(n, input, MADD_FFT_INVERSE);

    // Check if reconstructed signal matches original
    int passed = 1;
    for (uint64_t i = 0; i < n; i++) {
        double real_err = fabs(input[i].real - original[i].real);
        double imag_err = fabs(input[i].imag - original[i].imag);
        if (real_err > TOLERANCE || imag_err > TOLERANCE) {
            passed = 0;
            printf("  Reconstruction error at index %llu: real_err=%.6e, imag_err=%.6e\n",
                   (unsigned long long)i, real_err, imag_err);
            break;
        }
    }

    print_test_status("fft_ifft_consistency", passed);
    free(input);
    free(original);
}

// Test 3: FFT of a sinusoidal signal (should have peak at expected frequency)
static void test_sinusoidal_fft() {
    const uint64_t n = 32;  // Number of samples
    const double freq = 3.0;  // Signal frequency (cycles per frame)
    Cnum *input = (Cnum*)malloc(n * sizeof(Cnum));
    if (input == NULL) {
        printf("Test 'sinusoidal_fft': Memory allocation failed\n");
        test_failed = 1;
        return;
    }

    // Generate sinusoidal signal: x(t) = sin(2Ï€ft)
    for (uint64_t i = 0; i < n; i++) {
        double t = (double)i / n;
        double val = sin(2 * _CONSTANT_PI * freq * t);
        input[i] = Cnum_Value(val, 0.0);
    }

    // Perform FFT
    Fast_Fourier_Transform(n, input, MADD_FFT_FORWARD);

    // Find peak frequency (magnitude maximum)
    uint64_t peak_idx = 0;
    double max_mag = 0.0;
    for (uint64_t i = 0; i < n; i++) {
        double mag = Cnum_Radius(input[i]);
        if (mag > max_mag) {
            max_mag = mag;
            peak_idx = i;
        }
    }

    // Expected peak index for freq=3.0 in n=32 (should be 3 or n-3=29)
    int passed = (peak_idx == (uint64_t)freq || peak_idx == n - (uint64_t)freq);
    if (!passed) {
        printf("  Expected peak at index %llu or %llu, but found at %llu\n",
               (unsigned long long)freq, (unsigned long long)(n - freq),
               (unsigned long long)peak_idx);
    }

    print_test_status("sinusoidal_fft", passed);
    free(input);
}

// Test 4: Handle non-power-of-2 input (should pad to next power of 2)
static void test_non_power_of_2() {
    const uint64_t n = 5;  // Non-power-of-2 length
    const uint64_t expected_ceil = 8;  // Next power of 2 after 5
    Cnum *input = (Cnum*)Fast_Fourier_Transform_Malloc(n);
    if (input == NULL) {
        printf("Test 'non_power_of_2': Memory allocation failed\n");
        test_failed = 1;
        return;
    }

    // Initialize input with [1, 2, 3, 4, 5] (padded to 8 elements)
    input[0] = Cnum_Value(1.0, 0.0);
    input[1] = Cnum_Value(2.0, 0.0);
    input[2] = Cnum_Value(3.0, 0.0);
    input[3] = Cnum_Value(4.0, 0.0);
    input[4] = Cnum_Value(5.0, 0.0);
    // Elements 5-7 are already 0 due to Fast_Fourier_Transform_Malloc

    // Perform FFT + IFFT
    Fast_Fourier_Transform(n, input, MADD_FFT_FORWARD);
    Fast_Fourier_Transform(n, input, MADD_FFT_INVERSE);

    // Check first 5 elements match original (padded elements can be non-zero but small)
    int passed = 1;
    const double original_reals[5] = {1.0, 2.0, 3.0, 4.0, 5.0};
    for (uint64_t i = 0; i < n; i++) {
        double err = fabs(input[i].real - original_reals[i]);
        if (err > TOLERANCE) {
            passed = 0;
            printf("  Mismatch at index %llu: %.6f (expected %.6f)\n",
                   (unsigned long long)i, input[i].real, original_reals[i]);
            break;
        }
    }

    print_test_status("non_power_of_2", passed);
    free(input);
}

int main() {
    printf("Running FFT tests...\n\n");

    test_delta_function();
    test_fft_ifft_consistency();
    test_sinusoidal_fft();
    test_non_power_of_2();

    printf("\nTest summary: ");
    if (test_failed) {
        printf("Some tests failed\n");
        exit(EXIT_FAILURE);
    } else {
        printf("All tests passed\n");
        exit(EXIT_SUCCESS);
    }
}