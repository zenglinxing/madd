/* coding: utf-8 */
/*
This test code is generated by Deepseek-R1
*/
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "madd.h"  // 包含DCT2声明

#define TOLERANCE 1e-6
#define FAILED 1
#define PASSED 0

// 比较两个double数组是否在容忍范围内相等
int compare_arrays(const char* test_name, 
                   const double* expected, 
                   const double* actual, 
                   size_t n, 
                   double tolerance) {
    int errors = 0;
    
    for (size_t i = 0; i < n; i++) {
        double diff = fabs(expected[i] - actual[i]);
        if (diff > tolerance) {
            printf("  ERROR at index %zu: Expected %.8f, got %.8f (diff %.8f)\n", 
                   i, expected[i], actual[i], diff);
            errors++;
        }
    }
    
    if (errors > 0) {
        printf("%s - FAILED (%d errors)\n", test_name, errors);
        return FAILED;
    }
    
    printf("%s - PASSED\n", test_name);
    return PASSED;
}

// 测试1: 全零向量
int test_zero_vector() {
    const size_t n = 4;
    double input[] = {0.0, 0.0, 0.0, 0.0};
    double expected[] = {0.0, 0.0, 0.0, 0.0};
    
    Discrete_Cosine_Transform_2(n, input);
    return compare_arrays("Zero Vector", expected, input, n, TOLERANCE);
}

// 测试2: 全1向量
int test_all_ones() {
    const size_t n = 4;
    double input[] = {1.0, 1.0, 1.0, 1.0};
    double expected[] = {2.0, 0.0, 0.0, 0.0};  // 理论值
    
    Discrete_Cosine_Transform_2(n, input);
    return compare_arrays("All Ones", expected, input, n, TOLERANCE);
}

// 测试3: 简单向量[1,2,3,4]
int test_simple_vector() {
    const size_t n = 4;
    double input[] = {1.0, 2.0, 3.0, 4.0};
    // 预计算的参考值 (使用SciPy的dct函数计算)
    double expected[] = {5.        , -2.2304425 ,  0.        , -0.15851267};
    
    Discrete_Cosine_Transform_2(n, input);
    return compare_arrays("Simple Vector", expected, input, n, TOLERANCE);
}

// 测试4: 单元素向量
int test_single_element() {
    const size_t n = 1;
    double input[] = {5.0};
    double expected[] = {5.0};  // DCT2 of [a] is [a]
    
    Discrete_Cosine_Transform_2(n, input);
    return compare_arrays("Single Element", expected, input, n, TOLERANCE);
}

// 测试5: 随机向量 (验证逆变换特性)
int test_inverse_property() {
    const size_t n = 8;
    double original[] = {2.5, 1.8, 3.2, 0.9, 4.7, 2.1, 1.5, 3.8};
    double expected[] = {7.24784451, -0.57789797, -0.0593256 , -0.05356726,  1.16672619,
       -1.98073103,  1.05781873,  2.11065608};
    double transformed[8];
    double reconstructed[8];
    
    // 复制原始数据
    for (size_t i = 0; i < n; i++) {
        transformed[i] = original[i];
    }
    
    // 正向DCT2
    Discrete_Cosine_Transform_2(n, transformed);
    printf("transformed:\n");
    for (uint64_t i = 0; i < n; i++){
        printf("i=%llu\t%f\n", i, transformed[i]);
    }

    //return compare_arrays("Inverse Property - Forward DCT2", expected, transformed, n, TOLERANCE);
    
    // 反向DCT2 (使用逆变换公式)
    memcpy(reconstructed, transformed, n * sizeof(double));
    Inverse_Discrete_Cosine_Transform_2(n, reconstructed);
    
    // 比较原始和重建
    return compare_arrays("Inverse Property", original, reconstructed, n, TOLERANCE);
}

int test_dct2_non_power_of_2_inverse()
{
    printf("Test Non-Power-of-2 Length DCT2 Reverse\n");
    uint64_t n = 13, i;
    size_t size_n = n * sizeof(double);
    double *arr = (double*)malloc(size_n);
    double *iarr = (double*)malloc(size_n);
    double *rarr = (double*)malloc(size_n);
    RNG_Param rng = RNG_Init(10, 0);
    for (i=0; i<n; i++){
        arr[i] = iarr[i] = Rand(&rng);
    }
    Discrete_Cosine_Transform_2(n, iarr);
    memcpy(rarr, iarr, size_n);
    Inverse_Discrete_Cosine_Transform_2(n, rarr);

    int compare_res = compare_arrays("Test Non-Power-of-2", arr, rarr, n, 1e-6);
    return compare_res;
}

int main() {
    int test_results = PASSED;
    
    printf("Starting DCT-II Tests...\n\n");
    
    // 运行测试套件
    test_results |= test_zero_vector();
    test_results |= test_all_ones();
    test_results |= test_simple_vector();
    test_results |= test_single_element();
    test_results |= test_inverse_property();
    
    printf("\nTest Summary:\n");
    if (test_results == PASSED) {
        printf("All tests PASSED\n");
    } else {
        printf("Some tests FAILED\n");
        exit(EXIT_FAILURE);  // 有错误时退出
    }
    
    return EXIT_SUCCESS;
}