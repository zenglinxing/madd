/* coding: utf-8 */
/*
Generated by Deepseek
*/
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <assert.h>
#include <time.h>
#include "madd.h" // 包含链表声明

// ================== 测试辅助函数 ==================

// 创建并初始化节点
void test_basic_node_creation() {
    printf("Running test_basic_node_creation...\n");
    
    // 测试无数据节点
    Linked_List_Node node1;
    bool init_result = Linked_List_Init(&node1, 0);  // 保存结果到变量
    assert(init_result);
    assert(node1.buf == NULL);
    assert(node1.usize == 0);
    assert(node1.prev == NULL);
    assert(node1.next == NULL);
    assert(node1.flag_multithread == false);
    
    Linked_List_Destroy(&node1);
    
    // 测试有数据节点
    const size_t data_size = 100;
    Linked_List_Node node2;
    init_result = Linked_List_Init(&node2, data_size);  // 保存结果到变量
    assert(init_result);
    assert(node2.buf != NULL);
    assert(node2.usize == data_size);
    assert(node2.prev == NULL);
    assert(node2.next == NULL);
    assert(node2.flag_multithread == false);
    
    Linked_List_Destroy(&node2);
    
    printf("Passed!\n\n");
}

void test_unidirectional_linking() {
    printf("Running test_unidirectional_linking...\n");
    
    Linked_List_Node node1, node2;
    bool result1 = Linked_List_Init(&node1, 0);  // 保存结果到变量
    bool result2 = Linked_List_Init(&node2, 0);  // 保存结果到变量
    assert(result1);
    assert(result2);
    
    // 单向连接
    bool link_result = Linked_List_Link(&node1, &node2, false);  // 保存结果到变量
    assert(link_result);
    assert(node1.next == &node2);
    assert(node2.prev == NULL);
    
    // 清理
    Linked_List_Destroy(&node1);
    Linked_List_Destroy(&node2);
    
    printf("Passed!\n\n");
}

void test_bidirectional_linking() {
    printf("Running test_bidirectional_linking...\n");
    
    Linked_List_Node node1, node2;
    bool result1 = Linked_List_Init(&node1, 0);  // 保存结果到变量
    bool result2 = Linked_List_Init(&node2, 0);  // 保存结果到变量
    assert(result1);
    assert(result2);
    
    // 双向连接
    bool link_result = Linked_List_Link(&node1, &node2, true);  // 保存结果到变量
    assert(link_result);
    assert(node1.next == &node2);
    assert(node2.prev == &node1);
    
    // 清理
    Linked_List_Destroy(&node1);
    Linked_List_Destroy(&node2);
    
    printf("Passed!\n\n");
}

void test_deletion() {
    printf("Running test_deletion...\n");
    
    // 创建三节点链表: A <-> B <-> C
    Linked_List_Node nodeA, nodeB, nodeC;
    bool resultA = Linked_List_Init(&nodeA, 0);  // 保存结果到变量
    bool resultB = Linked_List_Init(&nodeB, 0);  // 保存结果到变量
    bool resultC = Linked_List_Init(&nodeC, 0);  // 保存结果到变量
    assert(resultA);
    assert(resultB);
    assert(resultC);
    
    // 创建连接
    bool link1_result = Linked_List_Link(&nodeA, &nodeB, true);  // 保存结果到变量
    bool link2_result = Linked_List_Link(&nodeB, &nodeC, true);  // 保存结果到变量
    assert(link1_result);
    assert(link2_result);
    
    // 删除中间节点
    bool delete_result = Linked_List_Delete(&nodeB);  // 保存结果到变量
    assert(delete_result);
    assert(nodeB.prev == NULL);
    assert(nodeB.next == NULL);
    assert(nodeA.next == &nodeC);
    assert(nodeC.prev == &nodeA);
    
    // 删除头节点
    delete_result = Linked_List_Delete(&nodeA);  // 保存结果到变量
    assert(delete_result);
    assert(nodeA.prev == NULL);
    assert(nodeA.next == NULL);
    assert(nodeC.prev == NULL);
    
    // 删除尾节点
    delete_result = Linked_List_Delete(&nodeC);  // 保存结果到变量
    assert(delete_result);
    assert(nodeC.prev == NULL);
    assert(nodeC.next == NULL);
    
    // 清理
    Linked_List_Destroy(&nodeA);
    Linked_List_Destroy(&nodeB);
    Linked_List_Destroy(&nodeC);
    
    printf("Passed!\n\n");
}

void test_insert_after() {
    printf("Running test_insert_after...\n");
    
    // 创建基础链表: A -> C
    Linked_List_Node nodeA, nodeB, nodeC;
    bool resultA = Linked_List_Init(&nodeA, 0);  // 保存结果到变量
    bool resultB = Linked_List_Init(&nodeB, 0);  // 保存结果到变量
    bool resultC = Linked_List_Init(&nodeC, 0);  // 保存结果到变量
    assert(resultA);
    assert(resultB);
    assert(resultC);
    
    // 创建A->C连接
    bool link_result = Linked_List_Link(&nodeA, &nodeC, false);  // 保存结果到变量
    assert(link_result);
    
    // 在A后插入B
    bool insert_result = Linked_List_Insert_After(&nodeA, &nodeB, true);  // 保存结果到变量
    assert(insert_result);
    
    // 验证连接: A <-> B -> C
    assert(nodeA.next == &nodeB);
    assert(nodeB.prev == &nodeA);
    assert(nodeB.next == &nodeC);
    assert(nodeC.prev == NULL);
    
    // 清理
    Linked_List_Destroy(&nodeA);
    Linked_List_Destroy(&nodeB);
    Linked_List_Destroy(&nodeC);
    
    printf("Passed!\n\n");
}

void test_circular_linking() {
    printf("Running test_circular_linking...\n");
    
    // 创建自环节点
    Linked_List_Node node;
    bool init_result = Linked_List_Init(&node, 0);  // 保存结果到变量
    //printf("init:\t%d\n", init_result);
    assert(init_result);
    
    // 创建自连接
    bool link_result = Linked_List_Link(&node, &node, true);  // 保存结果到变量
    //printf("link:\t%d\n", link_result);
    assert(link_result);
    
    // 验证自环
    assert(node.next == &node);
    assert(node.prev == &node);
    
    // 删除应失败（自环不能删除）
    bool delete_result = Linked_List_Delete(&node);  // 保存结果到变量
    //printf("delete:\t%d\n", delete_result);
    assert(!delete_result);
    
    // 清理
    //printf("destroying:\n");
    Linked_List_Destroy(&node);
    
    printf("Passed!\n\n");
}

#ifdef MADD_ENABLE_MULTITHREAD

#define THREAD_COUNT 1
#define OPERATIONS_PER_THREAD 1000

typedef struct {
    Linked_List_Node** nodes;
    int node_count;
} ThreadData;

// 线程工作函数：随机连接和删除节点
void thread_work(void* arg) {
    ThreadData* data = (ThreadData*)arg;
    Linked_List_Node** nodes = data->nodes;
    int count = data->node_count;
    
    //srand(time(NULL));
    srand(10);
    printf("seed set\n");
    fflush(stdout);
    
    for (int i = 0; i < OPERATIONS_PER_THREAD; i++) {
        /*if (i==35){
            bool res = RWLock_Try_Write_Lock(&nodes[14]->rwlock);
            if (res) RWLock_Write_Unlock(&nodes[14]->rwlock);
            printf("try lock 14:\t%d\n", res);
        }*/
        printf("i=%d\t%d\t", i, OPERATIONS_PER_THREAD);
        fflush(stdout);
        int op = rand() % 3;
        int idx1 = rand() % count;
        int idx2 = rand() % count;
        
        printf("op=%d\t", op);
        fflush(stdout);
        switch (op) {
            case 0: { // 连接
                printf("idx=%02d|%p idx=%02d|%p\t", idx1, nodes[idx1], idx2, nodes[idx2]);
                fflush(stdout);
                bool result = Linked_List_Link(nodes[idx1], nodes[idx2], rand() % 2);
                //(void)result; // 避免未使用警告
                break;
            }
            case 1: { // 删除
                printf("idx=%02d|%p\t\t", idx1, nodes[idx1]);
                fflush(stdout);
                if (nodes[idx1]->prev || nodes[idx1]->next) {
                    bool result = Linked_List_Delete(nodes[idx1]);
                    //(void)result; // 避免未使用警告
                }
                break;
            }
            case 2: { // 插入
                printf("idx=%02d|%p idx=%02d|%p\t", idx1, nodes[idx1], idx2, nodes[idx2]);
                fflush(stdout);
                bool result = Linked_List_Insert_After(nodes[idx1], nodes[idx2], rand() % 2);
                //(void)result; // 避免未使用警告
                break;
            }
        }
        printf("op=%d done\n", op);
        fflush(stdout);
    }
}

void test_multithread_safety() {
    printf("Running multithread safety test...\n");
    
    const int node_count = 20;
    Linked_List_Node* nodes[20];
    
    // 创建启用了多线程的节点
    for (int i = 0; i < node_count; i++) {
        nodes[i] = malloc(sizeof(Linked_List_Node));
        assert(nodes[i] != NULL);
        bool init_result = Linked_List_Init(nodes[i], 0);
        assert(init_result);
        #ifdef MADD_ENABLE_MULTITHREAD
        bool mt_result = Linked_List_Enable_Multithread(nodes[i]);
        assert(mt_result);
        #endif
    }
    
    // 创建线程
    Thread threads[THREAD_COUNT];
    ThreadData thread_data = {nodes, node_count};
    
    for (int i = 0; i < THREAD_COUNT; i++) {
        threads[i] = Thread_Create(thread_work, &thread_data);
        printf("thread %d created\n", i);
    }
    //Madd_Print(L"threads created\n");
    
    //thread_work(&thread_data);

    // 等待所有线程完成
    for (int i = 0; i < THREAD_COUNT; i++) {
        Thread_Join(threads[i]);
    }
    printf("threads joined\n");
    
    // 验证没有死锁或数据损坏
    int active_links = 0;
    for (int i = 0; i < node_count; i++) {
        if (nodes[i]->next || nodes[i]->prev) active_links++;
    }
    printf("Multithread operations completed. Active links: %d\n", active_links);
    
    // 清理
    for (int i = 0; i < node_count; i++) {
        Linked_List_Destroy(nodes[i]);
        free(nodes[i]);
    }
    
    printf("Passed!\n\n");
}
#endif

void test_memory_leaks() {
    printf("Running memory leak test...\n");
    
    // 在Valgrind或类似工具下运行此测试
    const int N = 1000;
    for (int i = 0; i < N; i++) {
        Linked_List_Node node;
        bool init_result = Linked_List_Init(&node, 100);
        assert(init_result);
        Linked_List_Destroy(&node);
    }
    
    printf("Passed! (Check with memory analysis tool)\n\n");
}

// ================== 主测试函数 ==================

int main() {
    madd_error_keep_print = false;
    printf("Starting Linked List Test Suite\n");
    printf("===============================\n\n");
    
    // 基本功能测试
    test_basic_node_creation();
    test_unidirectional_linking();
    test_bidirectional_linking();
    test_deletion();
    test_insert_after();
    test_circular_linking();
    
    // 压力测试
    printf("Running high-load test...\n");
    clock_t start = clock();
    
    const int N = 10000;
    Linked_List_Node* nodes[10000];
    
    // 创建节点
    for (int i = 0; i < N; i++) {
        nodes[i] = malloc(sizeof(Linked_List_Node));
        assert(nodes[i] != NULL);
        bool init_result = Linked_List_Init(nodes[i], sizeof(int));
        assert(init_result);
    }
    
    // 构建链表
    for (int i = 0; i < N - 1; i++) {
        bool link_result = Linked_List_Link(nodes[i], nodes[i + 1], true);
        assert(link_result);
    }
    
    // 随机删除节点
    srand(time(NULL));
    int delete_count = N / 2;
    for (int i = 0; i < delete_count; i++) {
        int idx = rand() % N;
        if (nodes[idx]) {
            bool delete_result = Linked_List_Delete(nodes[idx]);
            assert(delete_result);
            Linked_List_Destroy(nodes[idx]);
            free(nodes[idx]);
            nodes[idx] = NULL;
        }
    }
    
    // 验证剩余链表结构
    int valid_count = 0;
    Linked_List_Node* current = nodes[0] ? nodes[0] : nodes[1];
    while (current != NULL) {
        if (current->next) {
            assert(current->next->prev == current);
        }
        current = current->next;
        valid_count++;
    }
    
    // 清理剩余节点
    for (int i = 0; i < N; i++) {
        if (nodes[i]) {
            Linked_List_Destroy(nodes[i]);
            free(nodes[i]);
        }
    }
    
    double elapsed = (double)(clock() - start) / CLOCKS_PER_SEC;
    printf("High-load test completed. Nodes: %d, Deleted: %d, Valid: %d, Time: %.2fs\n\n",
           N, delete_count, valid_count, elapsed);
    
#ifdef MADD_ENABLE_MULTITHREAD
    test_multithread_safety();
#endif
    
    test_memory_leaks();
    
    printf("All tests passed successfully!\n");
    return 0;
}