/* coding: utf-8 */
/*
Generated by Deepseek
*/
#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <time.h>
#include "madd.h" // 包含链表声明

// ================== 测试辅助函数 ==================

// 创建并初始化节点
void test_basic_node_creation() {
    printf("Running test_basic_node_creation...\n");
    
    // 测试无数据节点
    Linked_List_Node node1;
    assert(Linked_List_Init(&node1, 0));
    assert(node1.buf == NULL);
    assert(node1.usize == 0);
    assert(node1.prev == NULL);
    assert(node1.next == NULL);
    Linked_List_Destroy(&node1);
    
    // 测试有数据节点
    const size_t data_size = 100;
    Linked_List_Node node2;
    assert(Linked_List_Init(&node2, data_size));
    assert(node2.buf != NULL);
    assert(node2.usize == data_size);
    assert(node2.prev == NULL);
    assert(node2.next == NULL);
    Linked_List_Destroy(&node2);
    
    printf("Passed!\n\n");
}

void test_unidirectional_linking() {
    printf("Running test_unidirectional_linking...\n");
    
    Linked_List_Node node1, node2;
    assert(Linked_List_Init(&node1, 0));
    assert(Linked_List_Init(&node2, 0));
    
    // 单向连接
    assert(Linked_List_Link(&node1, &node2, false));
    assert(node1.next == &node2);
    assert(node2.prev == NULL); // 单向连接，prev应为NULL
    
    // 清理
    Linked_List_Destroy(&node1);
    Linked_List_Destroy(&node2);
    
    printf("Passed!\n\n");
}

void test_bidirectional_linking() {
    printf("Running test_bidirectional_linking...\n");
    
    Linked_List_Node node1, node2;
    assert(Linked_List_Init(&node1, 0));
    assert(Linked_List_Init(&node2, 0));
    
    // 双向连接
    assert(Linked_List_Link(&node1, &node2, true));
    assert(node1.next == &node2);
    assert(node2.prev == &node1);
    
    // 清理
    Linked_List_Destroy(&node1);
    Linked_List_Destroy(&node2);
    
    printf("Passed!\n\n");
}

void test_deletion() {
    printf("Running test_deletion...\n");
    
    // 创建三节点链表: A <-> B <-> C
    Linked_List_Node nodeA, nodeB, nodeC;
    assert(Linked_List_Init(&nodeA, 0));
    assert(Linked_List_Init(&nodeB, 0));
    assert(Linked_List_Init(&nodeC, 0));
    
    assert(Linked_List_Link(&nodeA, &nodeB, true));
    assert(Linked_List_Link(&nodeB, &nodeC, true));
    
    // 删除中间节点
    assert(Linked_List_Delete(&nodeB));
    assert(nodeB.prev == NULL);
    assert(nodeB.next == NULL);
    assert(nodeA.next == &nodeC);
    assert(nodeC.prev == &nodeA);
    
    // 删除头节点
    assert(Linked_List_Delete(&nodeA));
    assert(nodeA.prev == NULL);
    assert(nodeA.next == NULL);
    assert(nodeC.prev == NULL);
    
    // 删除尾节点
    assert(Linked_List_Delete(&nodeC));
    assert(nodeC.prev == NULL);
    assert(nodeC.next == NULL);
    
    // 清理
    Linked_List_Destroy(&nodeA);
    Linked_List_Destroy(&nodeB);
    Linked_List_Destroy(&nodeC);
    
    printf("Passed!\n\n");
}

void test_insert_after() {
    printf("Running test_insert_after...\n");
    
    // 创建基础链表: A -> C
    Linked_List_Node nodeA, nodeB, nodeC;
    assert(Linked_List_Init(&nodeA, 0));
    assert(Linked_List_Init(&nodeB, 0));
    assert(Linked_List_Init(&nodeC, 0));
    
    assert(Linked_List_Link(&nodeA, &nodeC, false));
    
    // 在A后插入B
    assert(Linked_List_Insert_After(&nodeA, &nodeB, true));
    
    // 验证连接: A <-> B -> C
    assert(nodeA.next == &nodeB);
    assert(nodeB.prev == &nodeA);
    assert(nodeB.next == &nodeC);
    assert(nodeC.prev == NULL); // 单向连接
    
    // 清理
    Linked_List_Destroy(&nodeA);
    Linked_List_Destroy(&nodeB);
    Linked_List_Destroy(&nodeC);
    
    printf("Passed!\n\n");
}

void test_circular_linking() {
    printf("Running test_circular_linking...\n");
    
    // 创建自环节点
    Linked_List_Node node;
    assert(Linked_List_Init(&node, 0));
    assert(Linked_List_Link(&node, &node, true));
    
    // 验证自环
    assert(node.next == &node);
    assert(node.prev == &node);
    
    // 删除应失败（自环不能删除）
    assert(!Linked_List_Delete(&node));
    
    // 清理
    Linked_List_Destroy(&node);
    
    printf("Passed!\n\n");
}

#ifdef MADD_ENABLE_MULTITHREAD

#define THREAD_COUNT 4
#define OPERATIONS_PER_THREAD 1000

typedef struct {
    Linked_List_Node** nodes;
    int node_count;
} ThreadData;

// 线程工作函数：随机连接和删除节点
void thread_work(void* arg) {
    ThreadData* data = (ThreadData*)arg;
    Linked_List_Node** nodes = data->nodes;
    int count = data->node_count;
    
    srand(time(NULL));
    
    for (int i = 0; i < OPERATIONS_PER_THREAD; i++) {
        int op = rand() % 3;
        int idx1 = rand() % count;
        int idx2 = rand() % count;
        
        switch (op) {
            case 0: // 连接
                Linked_List_Link(nodes[idx1], nodes[idx2], rand() % 2);
                break;
                
            case 1: // 删除
                if (nodes[idx1]->prev || nodes[idx1]->next) {
                    Linked_List_Delete(nodes[idx1]);
                }
                break;
                
            case 2: // 插入
                Linked_List_Insert_After(nodes[idx1], nodes[idx2], rand() % 2);
                break;
        }
    }
}

void test_multithread_safety() {
    printf("Running multithread safety test...\n");
    
    const int node_count = 20;
    Linked_List_Node* nodes[20];
    
    // 创建启用了多线程的节点
    for (int i = 0; i < node_count; i++) {
        nodes[i] = malloc(sizeof(Linked_List_Node));
        assert(nodes[i] != NULL);
        assert(Linked_List_Init(nodes[i], 0));
        #ifdef MADD_ENABLE_MULTITHREAD
        assert(Linked_List_Enable_Multithread(nodes[i]));
        #endif
    }
    
    // 创建线程
    Thread threads[THREAD_COUNT];
    ThreadData thread_data = {nodes, node_count};
    
    for (int i = 0; i < THREAD_COUNT; i++) {
        threads[i] = Thread_Create(thread_work, &thread_data);
    }
    
    // 等待所有线程完成
    for (int i = 0; i < THREAD_COUNT; i++) {
        Thread_Join(threads[i]);
    }
    
    // 验证没有死锁或数据损坏
    int active_links = 0;
    for (int i = 0; i < node_count; i++) {
        if (nodes[i]->next || nodes[i]->prev) active_links++;
    }
    printf("Multithread operations completed. Active links: %d\n", active_links);
    
    // 清理
    for (int i = 0; i < node_count; i++) {
        Linked_List_Destroy(nodes[i]);
        free(nodes[i]);
    }
    
    printf("Passed!\n\n");
}
#endif

void test_memory_leaks() {
    printf("Running memory leak test...\n");
    
    // 在Valgrind或类似工具下运行此测试
    const int N = 1000;
    for (int i = 0; i < N; i++) {
        Linked_List_Node node;
        assert(Linked_List_Init(&node, 100));
        Linked_List_Destroy(&node);
    }
    
    printf("Passed! (Check with memory analysis tool)\n\n");
}

// ================== 主测试函数 ==================

int main() {
    madd_error_keep_print = true;
    printf("Starting Linked List Test Suite\n");
    printf("===============================\n\n");
    
    // 基本功能测试
    test_basic_node_creation();
    test_unidirectional_linking();
    test_bidirectional_linking();
    test_deletion();
    test_insert_after();
    test_circular_linking();
    
    // 压力测试
    printf("Running high-load test...\n");
    clock_t start = clock();
    
    const int N = 10000;
    
    // 创建节点数组
    Linked_List_Node* nodes[10000];
    for (int i = 0; i < N; i++) {
        nodes[i] = malloc(sizeof(Linked_List_Node));
        assert(nodes[i] != NULL);
        assert(Linked_List_Init(nodes[i], sizeof(int)));
    }
    
    // 构建链表
    for (int i = 0; i < N - 1; i++) {
        printf("i=%d\t");
        assert(Linked_List_Link(nodes[i], nodes[i + 1], true));
        //printf("i = %d\t%p\t%p\n", i, nodes[i]->prev, nodes[i]->next);
    }
    
    // 随机删除节点
    srand(10);
    int delete_count = N / 2;
    for (int i = 0; i < delete_count; i++) {
        int idx = rand() % N;
        if (nodes[idx]) {
            printf("idx = %d\ti = %d\t", idx, i);
            Linked_List_Delete(nodes[idx]);
            printf("deleted\n");
            Linked_List_Destroy(nodes[idx]);
            free(nodes[idx]);
            nodes[idx] = NULL;
        }
    }
    
    // 验证剩余链表结构
    int valid_count = 0;
    Linked_List_Node* current = nodes[0] ? nodes[0] : nodes[1];
    while (current != NULL) {
        if (current->next) {
            assert(current->next->prev == current);
        }
        current = current->next;
        valid_count++;
    }
    
    // 清理剩余节点
    for (int i = 0; i < N; i++) {
        if (nodes[i]) {
            Linked_List_Destroy(nodes[i]);
            free(nodes[i]);
        }
    }
    
    double elapsed = (double)(clock() - start) / CLOCKS_PER_SEC;
    printf("High-load test completed. Nodes: %d, Deleted: %d, Valid: %d, Time: %.2fs\n\n",
           N, delete_count, valid_count, elapsed);
    
#ifdef MADD_ENABLE_MULTITHREAD
    test_multithread_safety();
#endif
    
    test_memory_leaks();
    
    printf("All tests passed successfully!\n");
    return 0;
}