/* coding: utf-8 */
/*
This code is generated by Deepseek
*/
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <assert.h>
#include "madd.h"

// 比较函数
char int_compare(void *key1, void *key2, void *other_param) {
    int a = *(int *)key1;
    int b = *(int *)key2;
    if (a < b) return MADD_LESS;
    if (a > b) return MADD_GREATER;
    return MADD_SAME;
}

// 创建新节点
RB_Tree_Node* create_node(int value) {
    RB_Tree_Node* node = malloc(sizeof(RB_Tree_Node));
    int* key = malloc(sizeof(int));
    *key = value;
    node->key = key;
    return node;
}

// 释放节点内存
void free_node(RB_Tree_Node* node) {
    if (node) {
        free(node->key);
        free(node);
    }
}

// 验证红黑树性质
int verify_rb_properties(RB_Tree* T, RB_Tree_Node* node, int black_count, int* path_black_count) {
    if (node == &T->nil) {
        if (*path_black_count == -1) {
            *path_black_count = black_count;
            return 1;
        }
        return (black_count == *path_black_count) ? 1 : 0;
    }

    // 检查节点是否有效
    if (node->color != 'r' && node->color != 'b') {
        printf("[Validation Error] Invalid color '%c' at node: %d\n", node->color, *(int*)node->key);
        return 0;
    }
    
    // 红色节点检查
    if (node->color == 'r') {
        if (node->left->color == 'r' || node->right->color == 'r') {
            printf("[Validation Error] Red property violation at node: %d\n", *(int*)node->key);
            return 0;
        }
    }
    
    // 递归验证子树
    int new_black_count = black_count + (node->color == 'b');
    int left_ok = verify_rb_properties(T, node->left, new_black_count, path_black_count);
    int right_ok = verify_rb_properties(T, node->right, new_black_count, path_black_count);
    
    return left_ok && right_ok;
}

// 验证树结构
int validate_rb_tree(RB_Tree* T) {
    if (T->root == &T->nil) return 1;  // 空树有效
    
    // 性质：根节点必须是黑色
    if (T->root->color != 'b') {
        printf("[Validation Error] Root property violation\n");
        return 0;
    }
    
    int path_black_count = -1;
    return verify_rb_properties(T, T->root, 0, &path_black_count);
}

// 中序遍历打印树结构
void inorder_print(RB_Tree* T, RB_Tree_Node* node) {
    if (node == &T->nil) return;
    inorder_print(T, node->left);
    printf("%d(%c) ", *(int*)node->key, node->color);
    inorder_print(T, node->right);
}

// 打印整棵树
void print_tree(RB_Tree* T) {
    printf("Tree: ");
    inorder_print(T, T->root);
    printf("\n");
}

// 单元测试1：基本插入操作
int test_basic_insertion() {
    printf("\n=== Test 1: Basic Insertion ===\n");
    int test_result = 1;
    RB_Tree tree;
    RB_Tree_Init(&tree);
    
    int values[] = {10, 20, 5, 15, 25, 3, 7};
    int count = sizeof(values)/sizeof(values[0]);
    
    // 插入节点
    for (int i = 0; i < count; i++) {
        RB_Tree_Node* node = create_node(values[i]);
        RB_Tree_Insert(&tree, node, int_compare, NULL, RB_TREE_DISABLE_SAME_KEY);
        printf("Inserted: %d\n", values[i]);
        print_tree(&tree);
        
        int valid = validate_rb_tree(&tree);
        test_result &= valid;
        if (!valid) {
            printf("[Test Failure] Tree validation failed after inserting %d\n", values[i]);
        }
    }
    
    // 清理
    for (RB_Tree_Node* node = RB_Tree_Minimum(&tree, tree.root); 
         node != NULL && node != &tree.nil;  // deepseek didn't add "&& node != &tree.nil"
         node = RB_Tree_Successor(&tree, node)) {
        free_node(node);
    }
    
    return test_result;
}

// 单元测试2：删除操作
int test_deletion() {
    printf("\n=== Test 2: Deletion ===\n");
    int test_result = 1;
    RB_Tree tree;
    RB_Tree_Init(&tree);
    
    int values[] = {10, 20, 5, 15, 25, 3, 7, 30, 1};
    int count = sizeof(values)/sizeof(values[0]);
    RB_Tree_Node **nodes = malloc(count*sizeof(RB_Tree_Node*));
    
    // 插入节点
    for (int i = 0; i < count; i++) {
        nodes[i] = create_node(values[i]);
        RB_Tree_Insert(&tree, nodes[i], int_compare, NULL, RB_TREE_DISABLE_SAME_KEY);
    }
    printf("Initial tree: ");
    print_tree(&tree);
    
    // 验证初始树
    int initial_valid = validate_rb_tree(&tree);
    test_result &= initial_valid;
    if (!initial_valid) {
        printf("[Test Failure] Initial tree validation failed\n");
    }
    
    // 删除序列
    int delete_values[] = {20, 3, 10, 7, 15};
    int del_count = sizeof(delete_values)/sizeof(delete_values[0]);
    
    for (int i = 0; i < del_count; i++) {
        // 根据值查找节点
        RB_Tree_Node* node_to_delete = NULL;
        for (int j = 0; j < count; j++) {
            if (nodes[j] && *(int*)nodes[j]->key == delete_values[i]) {
                node_to_delete = nodes[j];
                nodes[j] = NULL; // 标记已删除
                break;
            }
        }
        
        if (node_to_delete) {
            RB_Tree_Delete(&tree, node_to_delete);
            printf("Deleted: %d\n", delete_values[i]);
            print_tree(&tree);
            
            int valid = validate_rb_tree(&tree);
            test_result &= valid;
            if (!valid) {
                printf("[Test Failure] Tree validation failed after deleting %d\n", delete_values[i]);
            }
            
            free_node(node_to_delete);
        }
    }
    
    // 清理剩余节点
    for (int i = 0; i < count; i++) {
        if (nodes[i]) {
            free_node(nodes[i]);
        }
    }
    
    return test_result;
}

// 单元测试3：重复键处理
int test_duplicate_keys() {
    printf("\n=== Test 3: Duplicate Keys ===\n");
    int test_result = 1;
    RB_Tree tree;
    RB_Tree_Init(&tree);
    
    // 允许重复键插入
    int values[] = {10, 10, 20, 20, 5, 5};
    int count = sizeof(values)/sizeof(values[0]);
    
    for (int i = 0; i < count; i++) {
        RB_Tree_Node* node = create_node(values[i]);
        RB_Tree_Insert(&tree, node, int_compare, NULL, RB_TREE_ENABLE_SAME_KEY);
        printf("Inserted: %d\n", values[i]);
        print_tree(&tree);
        
        int valid = validate_rb_tree(&tree);
        test_result &= valid;
        if (!valid) {
            printf("[Test Failure] Tree validation failed after inserting duplicate %d\n", values[i]);
        }
    }
    
    // 清理
    for (RB_Tree_Node* node = RB_Tree_Minimum(&tree, tree.root); 
         node != NULL && node != &tree.nil;  // deepseek didn't add "&& node != &tree.nil"
         node = RB_Tree_Successor(&tree, node)) {
        free_node(node);
    }
    
    return test_result;
}

// 单元测试4：最小/最大节点查找
int test_min_max() {
    printf("\n=== Test 4: Min/Max Operations ===\n");
    int test_result = 1;
    RB_Tree tree;
    RB_Tree_Init(&tree);
    
    int values[] = {15, 8, 25, 4, 10, 20, 30, 1, 6};
    int count = sizeof(values)/sizeof(values[0]);
    RB_Tree_Node **nodes = malloc(count*sizeof(RB_Tree_Node));
    
    for (int i = 0; i < count; i++) {
        nodes[i] = create_node(values[i]);
        RB_Tree_Insert(&tree, nodes[i], int_compare, NULL, RB_TREE_DISABLE_SAME_KEY);
    }
    print_tree(&tree);
    
    // 验证树结构
    int valid = validate_rb_tree(&tree);
    test_result &= valid;
    if (!valid) {
        printf("[Test Failure] Tree validation failed before min/max operations\n");
    }
    
    // 测试最小值
    RB_Tree_Node* min = RB_Tree_Minimum(&tree, tree.root);
    int min_value = (min) ? *(int*)min->key : -1;
    printf("Minimum: %d\n", min_value);
    test_result &= (min_value == 1);
    if (min_value != 1) {
        printf("[Test Failure] Expected min 1, got %d\n", min_value);
    }
    
    // 测试最大值
    RB_Tree_Node* max = RB_Tree_Maximum(&tree, tree.root);
    int max_value = (max) ? *(int*)max->key : -1;
    printf("Maximum: %d\n", max_value);
    test_result &= (max_value == 30);
    if (max_value != 30) {
        printf("[Test Failure] Expected max 30, got %d\n", max_value);
    }
    
    // 测试后继节点
    RB_Tree_Node* node = RB_Tree_Successor(&tree, min);
    int succ_value = (node) ? *(int*)node->key : -1;
    printf("Successor of %d: %d\n", min_value, succ_value);
    test_result &= (succ_value == 4);
    if (succ_value != 4) {
        printf("[Test Failure] Expected successor 4, got %d\n", succ_value);
    }
    
    // 测试前驱节点
    node = RB_Tree_Predecessor(&tree, max);
    int pred_value = (node) ? *(int*)node->key : -1;
    printf("Predecessor of %d: %d\n", max_value, pred_value);
    test_result &= (pred_value == 25);
    if (pred_value != 25) {
        printf("[Test Failure] Expected predecessor 25, got %d\n", pred_value);
    }
    
    // 清理
    for (int i = 0; i < count; i++) {
        free_node(nodes[i]);
    }
    
    free(nodes);
    return test_result;
}

// 单元测试5：空树操作
int test_empty_tree() {
    printf("\n=== Test 5: Empty Tree Operations ===\n");
    int test_result = 1;
    RB_Tree tree;
    RB_Tree_Init(&tree);
    
    // 测试空树操作
    RB_Tree_Node* min = RB_Tree_Minimum(&tree, tree.root);
    test_result &= (min == NULL);
    if (min != NULL) {
        printf("[Test Failure] Expected NULL min, got %p\n", (void*)min);
    }
    
    RB_Tree_Node* max = RB_Tree_Maximum(&tree, tree.root);
    test_result &= (max == NULL);
    if (max != NULL) {
        printf("[Test Failure] Expected NULL max, got %p\n", (void*)max);
    }
    
    int search_val = 5;
    RB_Tree_Node* search = RB_Tree_Search(&tree, tree.root, &search_val, int_compare, NULL, 0);
    test_result &= (search == NULL);
    if (search != NULL) {
        printf("[Test Failure] Expected NULL search, got %p\n", (void*)search);
    }
    
    printf("All empty tree operations handled correctly\n");
    return test_result;
}

// 性能测试：大规模随机操作
int performance_test() {
    printf("\n=== Performance Test ===\n");
    int test_result = 1;
    RB_Tree tree;
    RB_Tree_Init(&tree);
    const int NUM_OPS = 10000;
    
    clock_t start = clock();
    
    // 批量插入
    for (int i = 0; i < NUM_OPS; i++) {
        int* value = malloc(sizeof(int));
        *value = rand() % (NUM_OPS * 10);
        RB_Tree_Node* node = calloc(1, sizeof(RB_Tree_Node));
        node->key = value;
        RB_Tree_Insert(&tree, node, int_compare, NULL, RB_TREE_DISABLE_SAME_KEY);
    }
    
    // 随机删除（确保只删除存在的节点）
    int delete_count = NUM_OPS / 2;
    for (int i = 0; i < delete_count; i++) {
        int search_val = rand() % (NUM_OPS * 10);
        RB_Tree_Node* node = RB_Tree_Search(&tree, tree.root, &search_val, int_compare, NULL, 0);
        if (node && node != &tree.nil) {
            RB_Tree_Delete(&tree, node);
            free(node->key);
            free(node);
        }
    }
    
    clock_t end = clock();
    double elapsed = (double)(end - start) / CLOCKS_PER_SEC;
    printf("Completed %d operations in %.4f seconds\n", NUM_OPS + delete_count, elapsed);
    printf("Final tree size: %d nodes\n", NUM_OPS - delete_count);
    
    // 验证最终树结构
    int valid = validate_rb_tree(&tree);
    test_result &= valid;
    if (!valid) {
        printf("[Test Failure] Tree validation failed after performance test\n");
    }
    
    // 清理剩余节点
    for (RB_Tree_Node* node = RB_Tree_Minimum(&tree, tree.root); 
         node != NULL && node != &tree.nil;  // deepseek didn't add "&& node != &tree.nil"
         node = RB_Tree_Successor(&tree, node)) {
        free_node(node);
    }
    
    return test_result;
}

int main() {
    //madd_error_keep_print = true;

    srand(time(NULL));  // 初始化随机数生成器
    int passed = 0, total = 0;
    
    // 运行测试并收集结果
    printf("Starting Red-Black Tree Test Suite\n");
    printf("=================================\n");
    
    int result = test_basic_insertion();
    printf("Test 1: %s\n", result ? "PASSED" : "FAILED");
    passed += result; total++;
    
    result = test_deletion();
    printf("Test 2: %s\n", result ? "PASSED" : "FAILED");
    passed += result; total++;
    
    result = test_duplicate_keys();
    printf("Test 3: %s\n", result ? "PASSED" : "FAILED");
    passed += result; total++;
    
    result = test_min_max();
    printf("Test 4: %s\n", result ? "PASSED" : "FAILED");
    passed += result; total++;
    
    result = test_empty_tree();
    printf("Test 5: %s\n", result ? "PASSED" : "FAILED");
    passed += result; total++;
    
    result = performance_test();
    printf("Performance Test: %s\n", result ? "PASSED" : "FAILED");
    passed += result; total++;
    
    printf("\nTest Summary:\n");
    printf("=================================\n");
    printf("Total Tests: %d\n", total);
    printf("Passed: %d\n", passed);
    printf("Failed: %d\n", total - passed);
    printf("Success Rate: %.1f%%\n", (float)passed/total * 100);
    
    if (passed == total) {
        printf("\nAll tests passed successfully!\n");
        return 0;
    } else {
        printf("\nSome tests failed. Please review the error messages.\n");
        return 1;
    }
}