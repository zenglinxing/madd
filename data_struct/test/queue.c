/* coding: utf-8 */
/*
Generated by Deepseek
*/
#include <stdarg.h>
#include <assert.h>
#include "madd.h" // 包含 Madd_Print 声明

#define BUFFER_SIZE 1024

// Helper function: Format wide string
void madd_print(const wchar_t *format, ...) {
    wchar_t buffer[BUFFER_SIZE];
    va_list args;
    va_start(args, format);
    vswprintf(buffer, BUFFER_SIZE, format, args);
    va_end(args);
    Madd_Print(buffer);
}

// Test case functions
void Test_Queue_Basic(void) {
    Madd_Print(L"===== Starting Basic Functionality Test =====\n");
    
    Queue queue;
    bool init_result = Queue_Init(&queue, 3, sizeof(int));
    assert(init_result);
    if (init_result) Madd_Print(L"Queue initialization successful\n");
    else Madd_Print(L"Queue initialization failed\n");

    // Test empty queue operations
    int dummy;
    bool dequeue_result = Queue_Dequeue(&queue, &dummy);
    if (!dequeue_result) {
        Madd_Print(L"Empty queue dequeue failure test passed\n");
    } else {
        Madd_Print(L"Error: Empty queue dequeue succeeded\n");
        assert(!dequeue_result);
    }
    
    // Test enqueue/dequeue
    int data_in[] = {10, 20, 30, 40, 50};
    for (int i = 0; i < 5; i++) {
        bool enqueue_result = Queue_Enqueue(&queue, &data_in[i]);
        if (enqueue_result) {
            madd_print(L"Element %d enqueued successfully\n", data_in[i]);
        } else {
            madd_print(L"Error: Element %d failed to enqueue\n", data_in[i]);
            assert(enqueue_result);
        }
    }

    int data_out;
    bool head_result = Queue_Get_Head(&queue, &data_out);
    if (head_result) {
        madd_print(L"Head element: %d (should be 10)\n", data_out);
        assert(data_out == 10);
    } else {
        Madd_Print(L"Error: Failed to get head element\n");
        assert(head_result);
    }
    
    bool tail_result = Queue_Get_Last(&queue, &data_out);
    if (tail_result) {
        madd_print(L"Tail element: %d (should be 50)\n", data_out);
        assert(data_out == 50);
    } else {
        Madd_Print(L"Error: Failed to get tail element\n");
        assert(tail_result);
    }

    for (int i = 0; i < 5; i++) {
        bool dequeue_ok = Queue_Dequeue(&queue, &data_out);
        if (dequeue_ok) {
            madd_print(L"Dequeued element: %d (should be %d)\n", data_out, data_in[i]);
            assert(data_out == data_in[i]);
        } else {
            madd_print(L"Error: Failed to dequeue element %d\n", data_in[i]);
            assert(dequeue_ok);
        }
    }

    // Test empty queue state
    bool head_empty_result = Queue_Get_Head(&queue, &dummy);
    if (!head_empty_result) {
        Madd_Print(L"Empty queue head access test passed\n");
    } else {
        Madd_Print(L"Error: Empty queue returned head element\n");
        assert(!head_empty_result);
    }
    Queue_Destroy(&queue);
    Madd_Print(L"Queue destruction successful\n");
}

void Test_Queue_EdgeCases(void) {
    Madd_Print(L"===== Starting Edge Case Test =====\n");
    
    Queue queue;
    bool init_result = Queue_Init(&queue, 2, sizeof(int));
    assert(init_result);
    if (init_result) Madd_Print(L"Queue initialization successful\n");
    else Madd_Print(L"Queue initialization failed\n");
    
    // Test single node full state
    int data1 = 100, data2 = 200;
    bool enqueue1 = Queue_Enqueue(&queue, &data1);
    bool enqueue2 = Queue_Enqueue(&queue, &data2);
    assert(enqueue1 && enqueue2);
    if (enqueue1 && enqueue2) Madd_Print(L"Single node full capacity test passed\n");
    else Madd_Print(L"Error: Failed to fill single node\n");
    
    // Test node splitting
    int data3 = 300;
    bool split_result = Queue_Enqueue(&queue, &data3);
    assert(split_result);
    if (split_result) Madd_Print(L"Node auto-splitting test passed\n");
    else Madd_Print(L"Error: Failed to split node\n");
    
    int result;
    bool dequeue1 = Queue_Dequeue(&queue, &result);
    assert(dequeue1 && result == 100);
    bool dequeue2 = Queue_Dequeue(&queue, &result);
    assert(dequeue2 && result == 200);
    bool dequeue3 = Queue_Dequeue(&queue, &result);
    assert(dequeue3 && result == 300);
    if (dequeue1 && dequeue2 && dequeue3) {
        Madd_Print(L"Split node sequential dequeue test passed\n");
    } else {
        Madd_Print(L"Error: Failed to dequeue split node elements\n");
    }
    
    Queue_Destroy(&queue);
}

#ifdef MADD_ENABLE_MULTITHREAD

#define NUM_THREADS 4
#define NUM_ITEMS 1000

Queue g_queue;
Mutex g_mutex;
int g_counter = 0;

void Producer(void* arg) {
    for (int i = 0; i < NUM_ITEMS; i++) {
        Mutex_Lock(&g_mutex);
        int value = ++g_counter;
        Mutex_Unlock(&g_mutex);
        bool enqueue_ok = Queue_Enqueue(&g_queue, &value);
        if (!enqueue_ok) {
            Madd_Print(L"Producer error: Failed to enqueue value\n");
        }
    }
}

void Consumer(void* arg) {
    for (int i = 0; i < NUM_ITEMS; i++) {
        int value;
        bool dequeue_ok = false;
        while (!dequeue_ok) {
            dequeue_ok = Queue_Dequeue(&g_queue, &value);
            // Busy wait until data is available
        }
    }
}

void Test_Queue_Multithread(void) {
    Madd_Print(L"===== Starting Multithreaded Stress Test =====\n");
    
    bool init_ok = Queue_Init(&g_queue, 100, sizeof(int));
    assert(init_ok);
    if (!init_ok) Madd_Print(L"Queue initialization failed\n");
    
    bool multithread_ok = Queue_Enable_Multithread(&g_queue);
    assert(multithread_ok);
    if (!multithread_ok) Madd_Print(L"Multithread enable failed\n");
    
    Mutex_Init(&g_mutex);
    
    Thread producers[NUM_THREADS];
    Thread consumers[NUM_THREADS];
    
    // Create producer and consumer threads
    for (int i = 0; i < NUM_THREADS; i++) {
        producers[i] = Thread_Create(Producer, NULL);
        consumers[i] = Thread_Create(Consumer, NULL);
    }
    
    // Wait for all threads to complete
    for (int i = 0; i < NUM_THREADS; i++) {
        Thread_Join(producers[i]);
        Thread_Join(consumers[i]);
    }
    
    // Verify queue is finally empty
    int dummy;
    bool empty_result = Queue_Dequeue(&g_queue, &dummy);
    if (!empty_result) {
        madd_print(L"Multithreaded test completed, queue is empty (processed %d items)\n", 
                  NUM_THREADS * NUM_ITEMS);
    } else {
        Madd_Print(L"Error: Queue is not empty after test\n");
        assert(!empty_result);
    }
    
    Queue_Destroy(&g_queue);
    Mutex_Destroy(&g_mutex);
}
#endif

void Test_Queue_ErrorHandling(void) {
    Madd_Print(L"===== Starting Error Handling Test =====\n");
    
    // NULL pointer test
    bool null_init_result = Queue_Init(NULL, 10, sizeof(int));
    if (!null_init_result) {
        Madd_Print(L"NULL queue initialization test passed\n");
    } else {
        Madd_Print(L"Error: NULL queue initialization succeeded\n");
        assert(!null_init_result);
    }
    
    Queue queue;
    bool valid_init = Queue_Init(&queue, 10, sizeof(int));
    assert(valid_init);
    if (valid_init) Madd_Print(L"Valid queue initialization passed\n");
    else Madd_Print(L"Valid queue initialization failed\n");
    
    // Invalid enqueue
    bool null_enqueue = Queue_Enqueue(&queue, NULL);
    if (!null_enqueue) {
        Madd_Print(L"NULL element enqueue test passed\n");
    } else {
        Madd_Print(L"Error: NULL element enqueued successfully\n");
        assert(!null_enqueue);
    }
    
    // Invalid dequeue
    bool null_dequeue = Queue_Dequeue(&queue, NULL);
    if (!null_dequeue) {
        Madd_Print(L"NULL element dequeue test passed\n");
    } else {
        Madd_Print(L"Error: NULL element dequeued successfully\n");
        assert(!null_dequeue);
    }
    
    Queue_Destroy(&queue);
}

int main(int argc, char *argv[]) {
    //madd_error_keep_print = true;
    Madd_Print(L"start..\n");
    Test_Queue_Basic();
    Test_Queue_EdgeCases();
    Test_Queue_ErrorHandling();
    
#ifdef MADD_ENABLE_MULTITHREAD
    Test_Queue_Multithread();
#else
    Madd_Print(L"Skipping multithreaded test (MADD_ENABLE_MULTITHREAD not enabled)\n");
#endif

    Madd_Print(L"===== All Queue Tests Completed Successfully =====\n");
    return 0;
}