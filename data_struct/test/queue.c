/* coding: utf-8 */
/*
Generated by Deepseek
*/
#include "madd.h" // 包含 Madd_Print 声明
#include <stdarg.h>
#include <assert.h>

#define BUFFER_SIZE 1024

// Helper function: Format wide string
void madd_print(const wchar_t *format, ...) {
    wchar_t buffer[BUFFER_SIZE];
    va_list args;
    va_start(args, format);
    vswprintf(buffer, BUFFER_SIZE, format, args);
    va_end(args);
    Madd_Print(buffer);
}

// Test case functions
void Test_Queue_Basic(void) {
    Madd_Print(L"===== Starting Basic Functionality Test =====");
    
    Queue queue;
    assert(Queue_Init(&queue, 3, sizeof(int))); 
    Madd_Print(L"Queue initialization successful");

    // Test empty queue operations
    int dummy;
    if (!Queue_Dequeue(&queue, &dummy)) {
        Madd_Print(L"Empty queue dequeue failure test passed");
    } else {
        Madd_Print(L"Error: Empty queue dequeue succeeded");
        assert(0);
    }
    
    // Test enqueue/dequeue
    int data_in[] = {10, 20, 30, 40, 50};
    for (int i = 0; i < 5; i++) {
        if (Queue_Enqueue(&queue, &data_in[i])) {
            madd_print(L"Element %d enqueued successfully", data_in[i]);
        } else {
            madd_print(L"Error: Element %d failed to enqueue", data_in[i]);
            assert(0);
        }
    }

    int data_out;
    if (Queue_Get_Head(&queue, &data_out)) {
        madd_print(L"Head element: %d (should be 10)", data_out);
        assert(data_out == 10);
    } else {
        Madd_Print(L"Error: Failed to get head element");
        assert(0);
    }
    
    if (Queue_Get_Last(&queue, &data_out)) {
        madd_print(L"Tail element: %d (should be 50)", data_out);
        assert(data_out == 50);
    } else {
        Madd_Print(L"Error: Failed to get tail element");
        assert(0);
    }

    for (int i = 0; i < 5; i++) {
        if (Queue_Dequeue(&queue, &data_out)) {
            madd_print(L"Dequeued element: %d (should be %d)", data_out, data_in[i]);
            assert(data_out == data_in[i]);
        } else {
            madd_print(L"Error: Failed to dequeue element %d", data_in[i]);
            assert(0);
        }
    }

    // Test empty queue state
    if (!Queue_Get_Head(&queue, &dummy)) {
        Madd_Print(L"Empty queue head access test passed");
    } else {
        Madd_Print(L"Error: Empty queue returned head element");
        assert(0);
    }
    Queue_Destroy(&queue);
    Madd_Print(L"Queue destruction successful");
}

void Test_Queue_EdgeCases(void) {
    Madd_Print(L"===== Starting Edge Case Test =====");
    
    Queue queue;
    assert(Queue_Init(&queue, 2, sizeof(int)));
    
    // Test single node full state
    int data1 = 100, data2 = 200;
    assert(Queue_Enqueue(&queue, &data1));
    assert(Queue_Enqueue(&queue, &data2));
    Madd_Print(L"Single node full capacity test passed");
    
    // Test node splitting
    int data3 = 300;
    assert(Queue_Enqueue(&queue, &data3));
    Madd_Print(L"Node auto-splitting test passed");
    
    int result;
    assert(Queue_Dequeue(&queue, &result));
    assert(result == 100);
    assert(Queue_Dequeue(&queue, &result));
    assert(result == 200);
    assert(Queue_Dequeue(&queue, &result));
    assert(result == 300);
    Madd_Print(L"Split node sequential dequeue test passed");
    
    Queue_Destroy(&queue);
}

#ifdef MADD_ENABLE_MULTITHREAD

#define NUM_THREADS 4
#define NUM_ITEMS 1000

Queue g_queue;
Mutex g_mutex;
int g_counter = 0;

void Producer(void* arg) {
    for (int i = 0; i < NUM_ITEMS; i++) {
        Mutex_Lock(&g_mutex);
        int value = ++g_counter;
        Mutex_Unlock(&g_mutex);
        Queue_Enqueue(&g_queue, &value);
    }
}

void Consumer(void* arg) {
    for (int i = 0; i < NUM_ITEMS; i++) {
        int value;
        while (!Queue_Dequeue(&g_queue, &value)) {
            // Busy wait until data is available
        }
    }
}

void Test_Queue_Multithread(void) {
    Madd_Print(L"===== Starting Multithreaded Stress Test =====");
    
    assert(Queue_Init(&g_queue, 100, sizeof(int)));
    assert(Queue_Enable_Multithread(&g_queue));
    Mutex_Init(&g_mutex);
    
    Thread producers[NUM_THREADS];
    Thread consumers[NUM_THREADS];
    
    // Create producer and consumer threads
    for (int i = 0; i < NUM_THREADS; i++) {
        producers[i] = Thread_Create(Producer, NULL);
        consumers[i] = Thread_Create(Consumer, NULL);
    }
    
    // Wait for all threads to complete
    for (int i = 0; i < NUM_THREADS; i++) {
        Thread_Join(producers[i]);
        Thread_Join(consumers[i]);
    }
    
    // Verify queue is finally empty
    int dummy;
    if (!Queue_Dequeue(&g_queue, &dummy)) {
        madd_print(L"Multithreaded test completed, queue is finally empty (processed %d items)", 
                  NUM_THREADS * NUM_ITEMS);
    } else {
        Madd_Print(L"Error: Queue is not empty after test");
        assert(0);
    }
    
    Queue_Destroy(&g_queue);
    Mutex_Destroy(&g_mutex);
}
#endif

void Test_Queue_ErrorHandling(void) {
    Madd_Print(L"===== Starting Error Handling Test =====");
    
    // NULL pointer test
    if (!Queue_Init(NULL, 10, sizeof(int))) {
        Madd_Print(L"NULL queue initialization test passed");
    } else {
        Madd_Print(L"Error: NULL queue initialization succeeded");
        assert(0);
    }
    
    Queue queue;
    assert(Queue_Init(&queue, 10, sizeof(int)));
    
    // Invalid enqueue
    if (!Queue_Enqueue(&queue, NULL)) {
        Madd_Print(L"NULL element enqueue test passed");
    } else {
        Madd_Print(L"Error: NULL element enqueued successfully");
        assert(0);
    }
    
    // Invalid dequeue
    if (!Queue_Dequeue(&queue, NULL)) {
        Madd_Print(L"NULL element dequeue test passed");
    } else {
        Madd_Print(L"Error: NULL element dequeued successfully");
        assert(0);
    }
    
    Queue_Destroy(&queue);
}

int main() {
    Test_Queue_Basic();
    Test_Queue_EdgeCases();
    Test_Queue_ErrorHandling();
    
#ifdef MADD_ENABLE_MULTITHREAD
    Test_Queue_Multithread();
#else
    Madd_Print(L"Skipping multithreaded test (MADD_ENABLE_MULTITHREAD not enabled)");
#endif

    Madd_Print(L"===== All Queue Tests Completed Successfully =====");
    return 0;
}